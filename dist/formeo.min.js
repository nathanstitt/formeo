/*!
 * formeo - https://formeo.io
 * Version: 1.6.0
 * Author: Draggable https://draggable.io
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 206);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export dom */
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var mi18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var mi18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mi18n__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var DOM = function () {
  function DOM() {
    var _this2 = this;

    _defineProperty(this, "render", function (elem) {
      elem.id = "f-" + (elem.id || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* uuid */ "n"])());
      return _this2.create(elem);
    });

    _defineProperty(this, "create", function (elem, isPreview) {
      if (isPreview === void 0) {
        isPreview = false;
      }

      if (!elem) {
        return;
      }

      elem = _this2.processTagName(elem);
      var _this = _this2;
      var childType;
      var _elem = elem,
          tag = _elem.tag;
      var processed = ['children', 'content'];
      var i;
      var wrap = {
        attrs: {},
        className: [_helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].get(elem, 'config.inputWrap') || 'f-field-group'],
        children: [],
        config: {}
      };
      var element = document.createElement(tag);
      var appendChildren = {
        string: function string(children) {
          element.innerHTML += children;
        },
        object: function object(children) {
          return children && element.appendChild(_this.create(children, isPreview));
        },
        node: function node(children) {
          return element.appendChild(children);
        },
        component: function component(children) {
          return element.appendChild(children.dom);
        },
        array: function array(children) {
          for (var _i = 0; _i < children.length; _i++) {
            childType = _this.childType(children[_i]);
            appendChildren[childType](children[_i]);
          }
        },
        function: function _function(children) {
          children = children();
          childType = _this.childType(children);
          appendChildren[childType](children);
        },
        undefined: function undefined() {
          return null;
        },
        boolean: function boolean() {
          return null;
        }
      };
      processed.push('tag');

      if (elem.className) {
        var _elem2 = elem,
            className = _elem2.className;
        elem.attrs = Object.assign({}, elem.attrs, {
          className: className
        });
        delete elem.className;
      }

      if (elem.options) {
        var _elem3 = elem,
            options = _elem3.options;
        options = _this2.processOptions(options, elem, isPreview);

        if (_this2.holdsContent(element) && tag !== 'button') {
          appendChildren.array.call(_this2, options);
          delete elem.content;
        } else {
          _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].forEach(options, function (option) {
            wrap.children.push(_this.create(option, isPreview));
          });

          if (elem.attrs.className) {
            wrap.className = elem.attrs.className;
          }

          wrap.config = Object.assign({}, elem.config);
          return _this2.create(wrap, isPreview);
        }

        processed.push('options');
      }

      if (elem.attrs) {
        _this.processAttrs(elem, element, isPreview);

        processed.push('attrs');
      }

      if (elem.config) {
        if (elem.config.label && (elem.config.label && tag !== 'button' || ['radio', 'checkbox'].includes(_helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].get(elem, 'attrs.type'))) && !isPreview) {
          var label = _this.label(elem);

          if (!elem.config.hideLabel) {
            var wrapContent = [].concat(_this.labelAfter(elem) ? [element, label] : [label, element]);
            wrap.children.push(wrapContent);
          }
        }

        processed.push('config');
      }

      if (elem.content || elem.children) {
        var children = elem.content || elem.children;
        childType = _this.childType(children);

        if (!appendChildren[childType]) {
          console.error("childType: " + childType + " is not supported");
        }

        appendChildren[childType].call(_this2, children);
      }

      if (elem.dataset) {
        for (var data in elem.dataset) {
          if (elem.dataset.hasOwnProperty(data)) {
            element.dataset[data] = typeof elem.dataset[data] === 'function' ? elem.dataset[data]() : elem.dataset[data];
          }
        }

        processed.push('dataset');
      }

      if (elem.action) {
        _this2.actionHandler(element, elem.action);

        processed.push('action');
      }

      var remaining = _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].subtract(processed, Object.keys(elem));

      for (i = remaining.length - 1; i >= 0; i--) {
        element[remaining[i]] = elem[remaining[i]];
      }

      if (wrap.children.length) {
        element = _this2.create(wrap);
      }

      return element;
    });

    _defineProperty(this, "onRender", function (node, cb) {
      if (!node.parentElement) {
        window.requestAnimationFrame(function () {
          return _this2.onRender(node, cb);
        });
      } else {
        cb(node);
      }
    });

    _defineProperty(this, "toggleElementsByStr", function (elems, term) {
      var filteredElems = [];

      var containsTextCb = function containsTextCb(elem, contains) {
        if (contains) {
          elem.style.display = 'block';
          filteredElems.push(elem);
        } else {
          elem.style.display = 'none';
        }
      };

      dom.elementsContainText(elems, term, containsTextCb);
      return filteredElems;
    });

    _defineProperty(this, "elementsContainText", function (collection, term, cb) {
      var elementsContainingText = [];
      Object(_helpers__WEBPACK_IMPORTED_MODULE_0__[/* forEach */ "c"])(collection, function (elem) {
        var txt = elem.textContent.toLowerCase();
        var contains = txt.indexOf(term.toLowerCase()) !== -1;
        cb && cb(elem, contains);
        contains && elementsContainingText.push(elem);
      });
      return elementsContainingText;
    });

    _defineProperty(this, "generateOption", function (_ref) {
      var _attrs;

      var _ref$type = _ref.type,
          type = _ref$type === void 0 ? 'option' : _ref$type,
          label = _ref.label,
          value = _ref.value,
          _ref$i = _ref.i,
          i = _ref$i === void 0 ? 0 : _ref$i,
          selected = _ref.selected;
      var isOption = type === 'option';
      return {
        tag: isOption ? 'option' : 'input',
        attrs: (_attrs = {
          type: type,
          value: value || type + "-" + i
        }, _attrs[type === 'option' ? 'selected' : 'checked'] = selected || !i, _attrs),
        config: {
          label: label || mi18n__WEBPACK_IMPORTED_MODULE_1___default.a.get('labelCount', {
            label: mi18n__WEBPACK_IMPORTED_MODULE_1___default.a.get('option'),
            count: i
          })
        }
      };
    });

    _defineProperty(this, "makeOption", function (_ref2, selected, i18nKey) {
      var value = _ref2[0],
          label = _ref2[1];
      var option = {
        value: value,
        label: mi18n__WEBPACK_IMPORTED_MODULE_1___default.a.get(i18nKey + "." + label) || label
      };

      if (value === selected) {
        option.selected = true;
      }

      return option;
    });

    _defineProperty(this, "requiredMark", function () {
      return {
        tag: 'span',
        className: 'text-error',
        children: '*'
      };
    });

    _defineProperty(this, "removeEmpty", function (element) {
      var parent = element.parentElement;
      var type = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(element);
      var children = parent.getElementsByClassName("formeo-" + type);

      _this2.remove(element);

      if (!children.length) {
        if (!_this2.isStage(parent)) {
          return _this2.removeEmpty(parent);
        } else {
          _this2.emptyClass(parent);
        }
      }
    });

    _defineProperty(this, "btnTemplate", function (_ref3) {
      var _ref3$title = _ref3.title,
          title = _ref3$title === void 0 ? '' : _ref3$title,
          rest = _objectWithoutPropertiesLoose(_ref3, ["title"]);

      return _objectSpread({
        tag: 'button',
        attrs: {
          type: 'button',
          title: title
        }
      }, rest);
    });

    _defineProperty(this, "isControls", function (node) {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(node) === _constants__WEBPACK_IMPORTED_MODULE_6__[/* CONTROL_GROUP_CLASSNAME */ "o"];
    });

    _defineProperty(this, "isStage", function (node) {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(node) === _constants__WEBPACK_IMPORTED_MODULE_6__[/* STAGE_CLASSNAME */ "H"];
    });

    _defineProperty(this, "isRow", function (node) {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(node) === _constants__WEBPACK_IMPORTED_MODULE_6__[/* ROW_CLASSNAME */ "E"];
    });

    _defineProperty(this, "isColumn", function (node) {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(node) === _constants__WEBPACK_IMPORTED_MODULE_6__[/* COLUMN_CLASSNAME */ "g"];
    });

    _defineProperty(this, "isField", function (node) {
      return Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(node) === _constants__WEBPACK_IMPORTED_MODULE_6__[/* FIELD_CLASSNAME */ "z"];
    });

    _defineProperty(this, "asComponent", function (elem) {
      return _components__WEBPACK_IMPORTED_MODULE_4__[/* default */ "e"][Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(elem) + "s"].get(elem.id);
    });

    this.options = Object.create(null);

    this.styleSheet = function () {
      var style = document.createElement('style');
      style.setAttribute('media', 'screen');
      style.setAttribute('type', 'text/css');
      style.appendChild(document.createTextNode(''));
      document.head.appendChild(style);
      return style.sheet;
    }();
  }

  var _proto = DOM.prototype;

  _proto.processTagName = function processTagName(elem) {
    var tagName;

    if (typeof elem === 'string') {
      tagName = elem;
      elem = {
        tag: tagName
      };
    }

    if (elem.attrs) {
      var _elem$attrs = elem.attrs,
          tag = _elem$attrs.tag,
          restAttrs = _objectWithoutPropertiesLoose(_elem$attrs, ["tag"]);

      if (tag) {
        if (typeof tag === 'string') {
          tagName = tag;
        } else {
          var selectedTag = tag.find(function (t) {
            return t.selected === true;
          }) || tag[0];
          tagName = selectedTag.value;
        }
      }

      elem.attrs = restAttrs;
    }

    elem.tag = tagName || elem.tag || 'div';
    return elem;
  };

  _proto.actionHandler = function actionHandler(node, actions) {
    var handlers = {
      onRender: dom.onRender
    };
    var useCaptureEvts = ['focus', 'blur'];

    var defaultHandler = function defaultHandler(event) {
      return function (node, cb) {
        return node.addEventListener(event, cb, useCaptureEvts.includes(event));
      };
    };

    return Object.entries(actions).map(function (_ref4) {
      var key = _ref4[0],
          cb = _ref4[1];
      var action = handlers[key] || defaultHandler(key);
      return action(node, cb);
    });
  };

  _proto.icon = function icon(name) {
    if (name === void 0) {
      name = null;
    }

    if (!name) {
      return;
    }

    var iconPrefix = 'f-i-';
    var iconLink = document.getElementById(iconPrefix + name);
    var icon;
    var iconFontTemplates = {
      glyphicons: function glyphicons(icon) {
        return "<span class=\"glyphicon glyphicon-" + icon + "\" aria-hidden=\"true\"></span>";
      },
      'font-awesome': function fontAwesome(icon) {
        var _icon$split = icon.split(' '),
            style = _icon$split[0],
            name = _icon$split[1];

        return "<i class=\"" + style + " fa-" + name + "\"></i>";
      },
      fontello: function fontello(icon) {
        return "<i class=\"" + iconPrefix + icon + "\">" + icon + "</i>";
      }
    };

    if (iconLink) {
      icon = "<svg class=\"svg-icon " + iconPrefix + name + "\"><use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#" + iconPrefix + name + "\"></use></svg>";
    } else if (dom.options.iconFont) {
      icon = iconFontTemplates[dom.options.iconFont](name);
    } else {
      icon = name;
    }

    return icon;
  };

  _proto.processAttrs = function processAttrs(elem, element, isPreview) {
    var _elem$attrs2 = elem.attrs,
        attrs = _elem$attrs2 === void 0 ? {} : _elem$attrs2;

    if (!isPreview) {
      if (!attrs.name && this.isInput(elem.tag)) {
        element.setAttribute('name', Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* uuid */ "n"])(elem));
      }
    }

    Object.keys(attrs).forEach(function (attr) {
      var name = _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].safeAttrName(attr);
      var value = attrs[attr] || '';

      if (Array.isArray(value)) {
        if (typeof value[0] === 'object') {
          var selected = value.filter(function (t) {
            return t.selected === true;
          });
          value = selected.length ? selected[0].value : value[0].value;
        } else {
          value = value.join(' ');
        }
      }

      if (value) {
        element.setAttribute(name, value);
      }
    });
  };

  _proto.processOptions = function processOptions(options, elem, isPreview) {
    var action = elem.action,
        attrs = elem.attrs;
    var fieldType = attrs.type || elem.tag;
    var id = elem.id || attrs.id;

    var optionMap = function optionMap(option, i) {
      var label = option.label,
          rest = _objectWithoutPropertiesLoose(option, ["label"]);

      var defaultInput = function defaultInput() {
        var input = {
          tag: 'input',
          attrs: _objectSpread({
            name: attrs.name || id,
            type: fieldType,
            value: option.value || '',
            id: id + "-" + i
          }, rest),
          action: action
        };
        var optionLabel = {
          tag: 'label',
          attrs: {
            for: id + "-" + i
          },
          config: {
            inputWrap: 'form-check'
          },
          children: option.label
        };
        var inputWrap = {
          children: [input, optionLabel],
          className: ["f-" + fieldType]
        };

        if (elem.attrs.className) {
          elem.config.inputWrap = elem.attrs.className;
        }

        if (elem.config.inline) {
          inputWrap.className.push("f-" + fieldType + "-inline");
        }

        if (option.selected) {
          input.attrs.checked = true;
        }

        if (isPreview) {
          optionLabel.attrs.contenteditable = true;
        }

        return inputWrap;
      };

      var optionMarkup = {
        select: function select() {
          return {
            tag: 'option',
            attrs: option,
            children: option.label
          };
        },
        button: function button(option) {
          var type = option.type,
              label = option.label,
              className = option.className,
              id = option.id;
          return Object.assign({}, elem, {
            attrs: {
              type: type
            },
            className: className,
            id: id || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* uuid */ "n"])(),
            options: undefined,
            children: label,
            action: elem.action
          });
        },
        checkbox: defaultInput,
        radio: defaultInput
      };
      return optionMarkup[fieldType] && optionMarkup[fieldType](option);
    };

    var mappedOptions = options.map(optionMap);
    return mappedOptions;
  };

  _proto.holdsContent = function holdsContent(element) {
    return element.outerHTML.indexOf('/') !== -1;
  };

  _proto.isBlockInput = function isBlockInput(element) {
    return !this.isInput(element) && this.holdsContent(element);
  };

  _proto.isInput = function isInput(tag) {
    if (typeof tag !== 'string') {
      tag = tag.tagName;
    }

    return ['input', 'textarea', 'select'].indexOf(tag) !== -1;
  };

  _proto.parsedHtml = function parsedHtml(html) {
    var escapeElement = document.createElement('textarea');
    escapeElement.innerHTML = html;
    return escapeElement.textContent;
  };

  _proto.labelAfter = function labelAfter(elem) {
    var type = _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].get(elem, 'attrs.type');
    var labelAfter = _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].get(elem, 'config.labelAfter');
    var isCB = type === 'checkbox' || type === 'radio';
    return labelAfter !== undefined ? labelAfter : isCB;
  };

  _proto.label = function label(elem, fMap) {
    var required = _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].get(elem, 'attrs.required');
    var _elem$config$label = elem.config.label,
        labelText = _elem$config$label === void 0 ? '' : _elem$config$label;
    var elemId = elem.id,
        attrs = elem.attrs;

    if (typeof labelText === 'function') {
      labelText = labelText();
    }

    var fieldLabel = {
      tag: 'label',
      attrs: {
        for: elemId || attrs && attrs.id
      },
      className: [],
      children: [labelText, required && this.requiredMark()],
      action: {}
    };

    if (fMap) {
      delete fieldLabel.attrs.for;
      fieldLabel.attrs.contenteditable = true;
      fieldLabel.fMap = fMap;
    }

    return fieldLabel;
  };

  _proto.childType = function childType(content) {
    if (content === undefined) {
      return content;
    }

    return [['array', function (content) {
      return Array.isArray(content);
    }], ['node', function (content) {
      return content instanceof window.Node || content instanceof window.HTMLElement;
    }], ['component', function () {
      return content && content.dom;
    }], [typeof content, function () {
      return true;
    }]].find(function (typeCondition) {
      return typeCondition[1](content);
    })[0];
  };

  _proto.getStyle = function getStyle(elem, property) {
    if (property === void 0) {
      property = false;
    }

    var style;

    if (window.getComputedStyle) {
      style = window.getComputedStyle(elem, null);
    } else if (elem.currentStyle) {
      style = elem.currentStyle;
    }

    return property ? style[property] : style;
  };

  _proto.getElement = function getElement(elem) {
    var getElement = {
      node: function node() {
        return elem;
      },
      object: function object() {
        return document.getElementById(elem.id);
      },
      string: function string() {
        return document.getElementById(elem);
      }
    };
    var type = this.childType(elem);
    var element = getElement[type]();
    return element;
  };

  _proto.empty = function empty(elem) {
    while (elem.firstChild) {
      this.remove(elem.firstChild);
    }

    return elem;
  };

  _proto.clone = function clone(elem, parent) {
    var formData = {};

    var _this = this;

    var id = elem.id,
        fType = elem.fType;

    var dataClone = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* clone */ "b"])(formData[fType].get(id));

    var newIndex = Object(_helpers__WEBPACK_IMPORTED_MODULE_0__[/* indexOfNode */ "f"])(elem) + 1;
    var noParent = false;
    dataClone.id = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* uuid */ "n"])();
    formData[fType].set(dataClone.id, dataClone);

    if (!parent) {
      parent = elem.parentElement;
      noParent = true;
    }

    var cloneType = {
      rows: function rows() {
        dataClone.columns = [];
        var stage = _components__WEBPACK_IMPORTED_MODULE_4__[/* Stages */ "d"].active;
        var newRow = stage.addRow(null, dataClone.id);
        var columns = elem.getElementsByClassName(_constants__WEBPACK_IMPORTED_MODULE_6__[/* COLUMN_CLASSNAME */ "g"]);
        stage.insertBefore(newRow, stage.childNodes[newIndex]);
        _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].forEach(columns, function (column) {
          return _this.clone(column, newRow);
        });
        return newRow;
      },
      columns: function columns() {
        dataClone.fields = [];

        var newColumn = _this.addColumn(parent, dataClone.id);

        parent.insertBefore(newColumn, parent.childNodes[newIndex]);
        var fields = elem.getElementsByClassName(_constants__WEBPACK_IMPORTED_MODULE_6__[/* FIELD_CLASSNAME */ "z"]);

        if (noParent) {
          dom.columnWidths(parent);
        }

        _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].forEach(fields, function (field) {
          return _this.clone(field, newColumn);
        });
        return newColumn;
      },
      fields: function fields() {
        var newField = _this.addField(parent, dataClone.id);

        parent.insertBefore(newField, parent.childNodes[newIndex]);
        return newField;
      }
    };
    return cloneType[fType]();
  };

  _proto.remove = function remove(elem) {
    var type = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(elem);

    if (type) {
      return _components__WEBPACK_IMPORTED_MODULE_4__[/* default */ "e"].remove(type + "s." + elem.id);
    }

    return elem.parentElement.removeChild(elem);
  };

  _proto.removeClasses = function removeClasses(nodeList, className) {
    var removeClass = {
      string: function string(elem) {
        return elem.classList.remove(className);
      },
      array: function array(elem) {
        return className.forEach(function (name) {
          return elem.classList.remove(name);
        });
      }
    };
    removeClass.object = removeClass.string;
    _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].forEach(nodeList, removeClass[this.childType(className)]);
  };

  _proto.addClasses = function addClasses(nodeList, className) {
    var addClass = {
      string: function string(elem) {
        return elem.classList.add(className);
      },
      array: function array(elem) {
        return className.forEach(function (name) {
          return elem.classList.add(name);
        });
      }
    };
    _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].forEach(nodeList, addClass[this.childType(className)]);
  };

  _proto.columnWidths = function columnWidths(row) {
    var columns = row.getElementsByClassName(_constants__WEBPACK_IMPORTED_MODULE_6__[/* COLUMN_CLASSNAME */ "g"]);

    if (!columns.length) {
      return;
    }

    var width = parseFloat((100 / columns.length).toFixed(1)) / 1;
    this.removeClasses(columns, _constants__WEBPACK_IMPORTED_MODULE_6__[/* bsColRegExp */ "J"]);
    _helpers__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].forEach(columns, function (column) {
      _components__WEBPACK_IMPORTED_MODULE_4__[/* Columns */ "a"].get(column.id).refreshFieldPanels();
      var newColWidth = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* numToPercent */ "i"])(width);
      column.style.width = newColWidth;
      column.style.float = 'left';
      _components__WEBPACK_IMPORTED_MODULE_4__[/* Columns */ "a"].set(column.id + ".config.width", newColWidth);
      column.dataset.colWidth = newColWidth;
      document.dispatchEvent(_events__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].columnResized);
    });
    dom.updateColumnPreset(row);
  };

  _proto.formGroup = function formGroup(content, className) {
    if (className === void 0) {
      className = '';
    }

    return {
      className: ['f-field-group', className],
      children: content
    };
  };

  _proto.coords = function coords(element) {
    var elemPosition = element.getBoundingClientRect();
    var bodyRect = document.body.getBoundingClientRect();
    return {
      pageX: elemPosition.left + elemPosition.width / 2,
      pageY: elemPosition.top - bodyRect.top - elemPosition.height / 2
    };
  };

  _proto.clearStage = function clearStage(stage) {
    stage.classList.add('removing-all-fields');

    var resetStage = function resetStage() {
      dom.empty(stage);
      stage.classList.remove('removing-all-fields');
      dom.emptyClass(stage);
      _animation__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].slideDown(stage, 300);
    };

    _animation__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].slideUp(stage, 600, resetStage);
  };

  _proto.toggleSortable = function toggleSortable(elem, state) {
    var fType = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(elem);

    if (!fType) {
      return;
    }

    var pFtype = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* componentType */ "c"])(elem.parentElement);
    var sortable = dom[fType].get(elem.id).sortable;

    if (!state) {
      state = !sortable.option('disabled');
    }

    sortable.option('disabled', state);

    if (pFtype && ['rows', 'columns', 'stages'].includes(pFtype)) {
      this.toggleSortable(elem.parentElement, state);
    }
  };

  _proto.emptyClass = function emptyClass(elem) {
    var children = elem.getElementsByClassName(_constants__WEBPACK_IMPORTED_MODULE_6__[/* CHILD_CLASSNAME_MAP */ "e"].get(elem.classList.item(0)));
    elem.classList.toggle('empty', !children.length);
  };

  _proto.insertRule = function insertRule(rules) {
    var styleSheet = this.styleSheet;
    var rulesLength = styleSheet.cssRules.length;

    for (var i = 0, rl = rules.length; i < rl; i++) {
      var j = 1;
      var rule = rules[i];
      var selector = rules[i][0];
      var propStr = '';

      if (Object.prototype.toString.call(rule[1][0]) === '[object Array]') {
        rule = rule[1];
        j = 0;
      }

      for (var pl = rule.length; j < pl; j++) {
        var prop = rule[j];
        var important = prop[2] ? ' !important' : '';
        propStr += prop[0] + ":" + prop[1] + important + ";";
      }

      return styleSheet.insertRule(selector + " { " + propStr + " }", rulesLength);
    }
  };

  _createClass(DOM, [{
    key: "setOptions",
    set: function set(options) {
      this.options = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* merge */ "h"])(Object.assign({}, this.options, options));
    }
  }]);

  return DOM;
}();

var dom = new DOM();
/* harmony default export */ __webpack_exports__["a"] = (dom);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PACKAGE_NAME */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return POLYFILLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return FALLBACK_SVG_SPRITE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return CONTROL_GROUP_CLASSNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return STAGE_CLASSNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return ROW_CLASSNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return COLUMN_CLASSNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return FIELD_CLASSNAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return CHILD_CLASSNAME_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return COMPONENT_INDEX_TYPES; });
/* unused harmony export COMPONENT_TYPES */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return COMPONENT_TYPE_CLASSNAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return COMPONENT_TYPE_CLASSNAMES_LOOKUP; });
/* unused harmony export COMPONENT_TYPE_CLASSNAMES_ARRAY */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return COMPONENT_TYPE_CLASSNAMES_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return CHILD_TYPE_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return PARENT_TYPE_MAP; });
/* unused harmony export TYPE_CHILD_CLASSNAME_MAP */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return COLUMN_TEMPLATES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return CHANGE_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return SESSION_FORMDATA_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return SESSION_LOCALE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ANIMATION_SPEED_BASE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ANIMATION_SPEED_FAST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ANIMATION_SPEED_SLOW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return EVENT_FORMEO_SAVED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return EVENT_FORMEO_UPDATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return EVENT_FORMEO_UPDATED_STAGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return EVENT_FORMEO_UPDATED_ROW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return EVENT_FORMEO_UPDATED_COLUMN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return EVENT_FORMEO_UPDATED_FIELD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return EVENT_FORMEO_CLEARED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return EVENT_FORMEO_ON_RENDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return EVENT_FORMEO_CONDITION_UPDATED; });
/* unused harmony export COMPARISON_OPERATORS */
/* unused harmony export LOGICAL_OPERATORS */
/* unused harmony export ASSIGNMENT_OPERATORS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return CONDITION_INPUT_ORDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return FIELD_PROPERTY_MAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return OPERATORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return CONDITION_TEMPLATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return UUID_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return bsColRegExp; });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
var _package_json__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(28, 1);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var PACKAGE_NAME = _package_json__WEBPACK_IMPORTED_MODULE_0__["name"];
var POLYFILLS = [{
  name: 'cssPreload',
  src: '//cdnjs.cloudflare.com/ajax/libs/loadCSS/2.0.1/cssrelpreload.min.js'
}, {
  name: 'mutationObserver',
  src: '//cdn.jsdelivr.net/npm/mutationobserver-shim/dist/mutationobserver.min.js'
}, {
  name: 'fetch',
  src: 'https://unpkg.com/unfetch/polyfill'
}];
var FALLBACK_SVG_SPRITE = 'https://draggable.github.io/formeo/assets/img/formeo-sprite.svg';
var CONTROL_GROUP_CLASSNAME = 'control-group';
var STAGE_CLASSNAME = PACKAGE_NAME + "-stage";
var ROW_CLASSNAME = PACKAGE_NAME + "-row";
var COLUMN_CLASSNAME = PACKAGE_NAME + "-column";
var FIELD_CLASSNAME = PACKAGE_NAME + "-field";
var CHILD_CLASSNAME_MAP = new Map([[STAGE_CLASSNAME, ROW_CLASSNAME], [ROW_CLASSNAME, COLUMN_CLASSNAME], [COLUMN_CLASSNAME, FIELD_CLASSNAME]]);
var COMPONENT_INDEX_TYPES = ['external', 'stages', 'rows', 'columns', 'fields'];
var COMPONENT_TYPES = [{
  name: 'controls',
  className: CONTROL_GROUP_CLASSNAME
}, {
  name: 'stage',
  className: STAGE_CLASSNAME
}, {
  name: 'row',
  className: ROW_CLASSNAME
}, {
  name: 'column',
  className: COLUMN_CLASSNAME
}, {
  name: 'field',
  className: FIELD_CLASSNAME
}];
var COMPONENT_TYPE_CLASSNAMES = {
  controls: CONTROL_GROUP_CLASSNAME,
  stage: STAGE_CLASSNAME,
  row: ROW_CLASSNAME,
  column: COLUMN_CLASSNAME,
  field: FIELD_CLASSNAME
};
var COMPONENT_TYPE_CLASSNAMES_LOOKUP = Object.entries(COMPONENT_TYPE_CLASSNAMES).reduce(function (acc, _ref) {
  var _objectSpread2;

  var type = _ref[0],
      className = _ref[1];
  return _objectSpread({}, acc, (_objectSpread2 = {}, _objectSpread2[className] = type, _objectSpread2));
}, {});
var COMPONENT_TYPE_CLASSNAMES_ARRAY = Object.values(COMPONENT_TYPE_CLASSNAMES);
var COMPONENT_TYPE_CLASSNAMES_REGEXP = new RegExp("" + COMPONENT_TYPE_CLASSNAMES_ARRAY.join('|'), 'g');
var childTypeMap = COMPONENT_TYPES.map(function (_ref2, index, arr) {
  var name = _ref2.name;

  var _ref3 = arr[index + 1] || {},
      childName = _ref3.name;

  return childName && [name, childName];
}).filter(Boolean);
var parentTypeMap = childTypeMap.slice().map(function (typeMap) {
  return typeMap.slice().reverse();
}).reverse();
var CHILD_TYPE_MAP = new Map(childTypeMap);
var PARENT_TYPE_MAP = new Map(parentTypeMap.slice());
var TYPE_CHILD_CLASSNAME_MAP = new Map([['stage', ROW_CLASSNAME], ['row', COLUMN_CLASSNAME], ['column', FIELD_CLASSNAME]]);
var columnTemplates = [[{
  value: '100.0',
  label: '100%'
}], [{
  value: '50.0,50.0',
  label: '50 | 50'
}, {
  value: '33.3,66.6',
  label: '33 | 66'
}, {
  value: '66.6,33.3',
  label: '66 | 33'
}], [{
  value: '33.3,33.3,33.3',
  label: '33 | 33 | 33'
}, {
  value: '25.0,25.0,50.0',
  label: '25 | 25 | 50'
}, {
  value: '50.0,25.0,25.0',
  label: '50 | 25 | 25'
}, {
  value: '25.0,50.0,25.0',
  label: '25 | 50 | 25'
}], [{
  value: '25.0,25.0,25.0,25.0',
  label: '25 | 25 | 25 | 25'
}], [{
  value: '20.0,20.0,20.0,20.0,20.0',
  label: '20 | 20 | 20 | 20 | 20'
}], [{
  value: '16.66,16.66,16.66,16.66,16.66,16.66',
  label: '16.66 | 16.66 | 16.66 | 16.66 | 16.66 | 16.66'
}]];
var COLUMN_TEMPLATES = new Map(columnTemplates.reduce(function (acc, cur, idx) {
  acc.push([idx, cur]);
  return acc;
}));
var CHANGE_TYPES = [{
  type: 'added',
  condition: function condition(o, n) {
    return Boolean(o === undefined && n);
  }
}];
var SESSION_FORMDATA_KEY = _package_json__WEBPACK_IMPORTED_MODULE_0__["name"] + "-formData";
var SESSION_LOCALE_KEY = _package_json__WEBPACK_IMPORTED_MODULE_0__["name"] + "-locale";
var ANIMATION_SPEED_BASE = 333;
var ANIMATION_SPEED_FAST = Math.round(ANIMATION_SPEED_BASE / 2);
var ANIMATION_SPEED_SLOW = Math.round(ANIMATION_SPEED_BASE * 2);
var EVENT_FORMEO_SAVED = 'formeoSaved';
var EVENT_FORMEO_UPDATED = 'formeoUpdated';
var EVENT_FORMEO_UPDATED_STAGE = 'formeoUpdatedStage';
var EVENT_FORMEO_UPDATED_ROW = 'formeoUpdatedRow';
var EVENT_FORMEO_UPDATED_COLUMN = 'formeoUpdatedColumn';
var EVENT_FORMEO_UPDATED_FIELD = 'formeoUpdatedField';
var EVENT_FORMEO_CLEARED = 'formeoCleared';
var EVENT_FORMEO_ON_RENDER = 'formeoOnRender';
var EVENT_FORMEO_CONDITION_UPDATED = 'formeoConditionUpdated';
var COMPARISON_OPERATORS = {
  equals: '==',
  notEquals: '!=',
  contains: '⊃',
  notContains: '!⊃'
};
var LOGICAL_OPERATORS = {
  and: '&&',
  or: '||'
};
var visiblityConfigs = {
  isVisible: 'config.isVisible',
  isNotVisible: 'config.isNotVisible'
};
var ASSIGNMENT_OPERATORS = {
  equals: '='
};
var CONDITION_INPUT_ORDER = ['label', 'logical', 'source', 'thenTarget', 'sourceProperty', 'comparison', 'target', 'targetProperty', 'assignment', 'value'];
var FIELD_PROPERTY_MAP = _objectSpread({
  value: 'attrs.value',
  checked: 'attrs.checked'
}, visiblityConfigs);
var OPERATORS = {
  comparison: COMPARISON_OPERATORS,
  assignment: ASSIGNMENT_OPERATORS,
  logical: LOGICAL_OPERATORS,
  property: FIELD_PROPERTY_MAP
};
var CONDITION_TEMPLATE = function CONDITION_TEMPLATE() {
  return {
    if: [{
      source: '',
      sourceProperty: '',
      comparison: '',
      target: '',
      targetProperty: ''
    }],
    then: [{
      target: '',
      targetProperty: '',
      assignment: '',
      value: ''
    }]
  };
};
var UUID_REGEXP = /(\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b)/gi;
var bsColRegExp = /\bcol-\w+-\d+/g;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*!
 * mi18n - https://github.com/Draggable/mi18n
 * Version: 0.4.7
 * Author: Kevin Chappell <kevin.b.chappell@gmail.com> (http://kevin-chappell.com)
 */
module.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=7)}([function(e,t,n){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o=n(2),i=n(10),s=Object.prototype.toString;function a(e){return"[object Array]"===s.call(e)}function u(e){return null!==e&&"object"===(void 0===e?"undefined":r(e))}function c(e){return"[object Function]"===s.call(e)}function f(e,t){if(null!==e&&void 0!==e)if("object"!==(void 0===e?"undefined":r(e))&&(e=[e]),a(e))for(var n=0,o=e.length;n<o;n++)t.call(null,e[n],n,e);else for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.call(null,e[i],i,e)}e.exports={isArray:a,isArrayBuffer:function(e){return"[object ArrayBuffer]"===s.call(e)},isBuffer:i,isFormData:function(e){return"undefined"!=typeof FormData&&e instanceof FormData},isArrayBufferView:function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&e.buffer instanceof ArrayBuffer},isString:function(e){return"string"==typeof e},isNumber:function(e){return"number"==typeof e},isObject:u,isUndefined:function(e){return void 0===e},isDate:function(e){return"[object Date]"===s.call(e)},isFile:function(e){return"[object File]"===s.call(e)},isBlob:function(e){return"[object Blob]"===s.call(e)},isFunction:c,isStream:function(e){return u(e)&&c(e.pipe)},isURLSearchParams:function(e){return"undefined"!=typeof URLSearchParams&&e instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product)&&"undefined"!=typeof window&&"undefined"!=typeof document},forEach:f,merge:function e(){var t={};function n(n,o){"object"===r(t[o])&&"object"===(void 0===n?"undefined":r(n))?t[o]=e(t[o],n):t[o]=n}for(var o=0,i=arguments.length;o<i;o++)f(arguments[o],n);return t},extend:function(e,t,n){return f(t,function(t,r){e[r]=n&&"function"==typeof t?o(t,n):t}),e},trim:function(e){return e.replace(/^\s*/,"").replace(/\s*$/,"")}}},function(e,t,n){"use strict";(function(t){var r=n(0),o=n(13),i={"Content-Type":"application/x-www-form-urlencoded"};function s(e,t){!r.isUndefined(e)&&r.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t)}var a={adapter:function(){var e;return"undefined"!=typeof XMLHttpRequest?e=n(3):void 0!==t&&(e=n(3)),e}(),transformRequest:[function(e,t){return o(t,"Content-Type"),r.isFormData(e)||r.isArrayBuffer(e)||r.isBuffer(e)||r.isStream(e)||r.isFile(e)||r.isBlob(e)?e:r.isArrayBufferView(e)?e.buffer:r.isURLSearchParams(e)?(s(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString()):r.isObject(e)?(s(t,"application/json;charset=utf-8"),JSON.stringify(e)):e}],transformResponse:[function(e){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};r.forEach(["delete","get","head"],function(e){a.headers[e]={}}),r.forEach(["post","put","patch"],function(e){a.headers[e]=r.merge(i)}),e.exports=a}).call(this,n(12))},function(e,t,n){"use strict";e.exports=function(e,t){return function(){for(var n=new Array(arguments.length),r=0;r<n.length;r++)n[r]=arguments[r];return e.apply(t,n)}}},function(e,t,n){"use strict";var r=n(0),o=n(14),i=n(16),s=n(17),a=n(18),u=n(4),c="undefined"!=typeof window&&window.btoa&&window.btoa.bind(window)||n(19);e.exports=function(e){return new Promise(function(t,f){var l=e.data,p=e.headers;r.isFormData(l)&&delete p["Content-Type"];var d=new XMLHttpRequest,h="onreadystatechange",g=!1;if("undefined"==typeof window||!window.XDomainRequest||"withCredentials"in d||a(e.url)||(d=new window.XDomainRequest,h="onload",g=!0,d.onprogress=function(){},d.ontimeout=function(){}),e.auth){var m=e.auth.username||"",y=e.auth.password||"";p.Authorization="Basic "+c(m+":"+y)}if(d.open(e.method.toUpperCase(),i(e.url,e.params,e.paramsSerializer),!0),d.timeout=e.timeout,d[h]=function(){if(d&&(4===d.readyState||g)&&(0!==d.status||d.responseURL&&0===d.responseURL.indexOf("file:"))){var n="getAllResponseHeaders"in d?s(d.getAllResponseHeaders()):null,r={data:e.responseType&&"text"!==e.responseType?d.response:d.responseText,status:1223===d.status?204:d.status,statusText:1223===d.status?"No Content":d.statusText,headers:n,config:e,request:d};o(t,f,r),d=null}},d.onerror=function(){f(u("Network Error",e,null,d)),d=null},d.ontimeout=function(){f(u("timeout of "+e.timeout+"ms exceeded",e,"ECONNABORTED",d)),d=null},r.isStandardBrowserEnv()){var v=n(20),w=(e.withCredentials||a(e.url))&&e.xsrfCookieName?v.read(e.xsrfCookieName):void 0;w&&(p[e.xsrfHeaderName]=w)}if("setRequestHeader"in d&&r.forEach(p,function(e,t){void 0===l&&"content-type"===t.toLowerCase()?delete p[t]:d.setRequestHeader(t,e)}),e.withCredentials&&(d.withCredentials=!0),e.responseType)try{d.responseType=e.responseType}catch(t){if("json"!==e.responseType)throw t}"function"==typeof e.onDownloadProgress&&d.addEventListener("progress",e.onDownloadProgress),"function"==typeof e.onUploadProgress&&d.upload&&d.upload.addEventListener("progress",e.onUploadProgress),e.cancelToken&&e.cancelToken.promise.then(function(e){d&&(d.abort(),f(e),d=null)}),void 0===l&&(l=null),d.send(l)})}},function(e,t,n){"use strict";var r=n(15);e.exports=function(e,t,n,o,i){var s=new Error(e);return r(s,t,n,o,i)}},function(e,t,n){"use strict";e.exports=function(e){return!(!e||!e.__CANCEL__)}},function(e,t,n){"use strict";function r(e){this.message=e}r.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},r.prototype.__CANCEL__=!0,e.exports=r},function(e,t,n){"use strict";t.__esModule=!0,t.I18N=void 0;var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),i=n(8),s={extension:".lang",location:"assets/lang/",langs:["en-US"],locale:"en-US",override:{}},a=t.I18N=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.langs=Object.create(null),this.loaded=[],this.processConfig(t)}return e.prototype.processConfig=function(e){var t=this,n=Object.assign({},s,e),r=n.location,o=function(e,t){var n={};for(var r in e)t.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}(n,["location"]),i=r.replace(/\/?$/,"/");this.config=Object.assign({},{location:i},o);var a=this.config,u=a.override,c=a.preloaded,f=void 0===c?{}:c,l=Object.entries(this.langs).concat(Object.entries(u||f));this.langs=l.reduce(function(e,n){var r=n[0],o=n[1];return e[r]=t.applyLanguage.call(t,r,o),e},{}),this.locale=this.config.locale||this.config.langs[0]},e.prototype.init=function(e){return this.processConfig.call(this,Object.assign({},this.config,e)),this.setCurrent(this.locale)},e.prototype.addLanguage=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t="string"==typeof t?this.processFile.call(this,t):t,this.applyLanguage.call(this,e,t),this.config.langs.push("locale")},e.prototype.getValue=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.locale;return this.langs[t]&&this.langs[t][e]||this.getFallbackValue(e)},e.prototype.getFallbackValue=function(e){var t=Object.values(this.langs).find(function(t){return t[e]});return t&&t[e]},e.prototype.makeSafe=function(e){var t={"{":"\\{","}":"\\}","|":"\\|"};return e=e.replace(/\{|\}|\|/g,function(e){return t[e]}),new RegExp(e,"g")},e.prototype.put=function(e,t){return this.current[e]=t},e.prototype.get=function(e,t){var n=this.getValue(e);if(n){var o=n.match(/\{[^}]+?\}/g),i=void 0;if(t&&o)if("object"===(void 0===t?"undefined":r(t)))for(var s=0;s<o.length;s++)i=o[s].substring(1,o[s].length-1),n=n.replace(this.makeSafe(o[s]),t[i]||"");else n=n.replace(/\{[^}]+?\}/g,t);return n}},e.prototype.fromFile=function(e){for(var t,n=e.split("\n"),r={},o=0;o<n.length;o++)(t=n[o].match(/^(.+?) *?= *?([^\n]+)/))&&(r[t[1]]=t[2].replace(/^\s+|\s+$/,""));return r},e.prototype.processFile=function(e){return this.fromFile(e.replace(/\n\n/g,"\n"))},e.prototype.loadLang=function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=this;return new Promise(function(r,o){if(-1!==n.loaded.indexOf(e)&&t)return n.applyLanguage.call(n,n.langs[e]),r(n.langs[e]);var s=[n.config.location,e,n.config.extension].join("");return(0,i.get)(s).then(function(t){var o=t.data,i=n.processFile(o);return n.applyLanguage.call(n,e,i),n.loaded.push(e),r(n.langs[e])}).catch(function(){var t=n.applyLanguage.call(n,e);r(t)})})},e.prototype.applyLanguage=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.config.override[e]||{},r=this.langs[e]||{};return this.langs[e]=Object.assign({},r,t,n),this.langs[e]},e.prototype.setCurrent=function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"en-US";return this.loadLang(t).then(function(){return e.locale=t,e.current=e.langs[t],e.current})},o(e,[{key:"getLangs",get:function(){return this.config.langs}}]),e}();t.default=new a},function(e,t,n){"use strict";e.exports=n(9)},function(e,t,n){"use strict";var r=n(0),o=n(2),i=n(11),s=n(1);function a(e){var t=new i(e),n=o(i.prototype.request,t);return r.extend(n,i.prototype,t),r.extend(n,t),n}var u=a(s);u.Axios=i,u.create=function(e){return a(r.merge(s,e))},u.Cancel=n(6),u.CancelToken=n(26),u.isCancel=n(5),u.all=function(e){return Promise.all(e)},u.spread=n(27),e.exports=u,e.exports.default=u},function(e,t,n){"use strict";
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */function r(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}e.exports=function(e){return null!=e&&(r(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&r(e.slice(0,0))}(e)||!!e._isBuffer)}},function(e,t,n){"use strict";var r=n(1),o=n(0),i=n(21),s=n(22);function a(e){this.defaults=e,this.interceptors={request:new i,response:new i}}a.prototype.request=function(e){"string"==typeof e&&(e=o.merge({url:arguments[0]},arguments[1])),(e=o.merge(r,{method:"get"},this.defaults,e)).method=e.method.toLowerCase();var t=[s,void 0],n=Promise.resolve(e);for(this.interceptors.request.forEach(function(e){t.unshift(e.fulfilled,e.rejected)}),this.interceptors.response.forEach(function(e){t.push(e.fulfilled,e.rejected)});t.length;)n=n.then(t.shift(),t.shift());return n},o.forEach(["delete","get","head","options"],function(e){a.prototype[e]=function(t,n){return this.request(o.merge(n||{},{method:e,url:t}))}}),o.forEach(["post","put","patch"],function(e){a.prototype[e]=function(t,n,r){return this.request(o.merge(r||{},{method:e,url:t,data:n}))}}),e.exports=a},function(e,t,n){"use strict";var r,o,i=e.exports={};function s(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function u(e){if(r===setTimeout)return setTimeout(e,0);if((r===s||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:s}catch(e){r=s}try{o="function"==typeof clearTimeout?clearTimeout:a}catch(e){o=a}}();var c,f=[],l=!1,p=-1;function d(){l&&c&&(l=!1,c.length?f=c.concat(f):p=-1,f.length&&h())}function h(){if(!l){var e=u(d);l=!0;for(var t=f.length;t;){for(c=f,f=[];++p<t;)c&&c[p].run();p=-1,t=f.length}c=null,l=!1,function(e){if(o===clearTimeout)return clearTimeout(e);if((o===a||!o)&&clearTimeout)return o=clearTimeout,clearTimeout(e);try{o(e)}catch(t){try{return o.call(null,e)}catch(t){return o.call(this,e)}}}(e)}}function g(e,t){this.fun=e,this.array=t}function m(){}i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];f.push(new g(e,t)),1!==f.length||l||u(h)},g.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=m,i.addListener=m,i.once=m,i.off=m,i.removeListener=m,i.removeAllListeners=m,i.emit=m,i.prependListener=m,i.prependOnceListener=m,i.listeners=function(e){return[]},i.binding=function(e){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(e){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(e,t,n){"use strict";var r=n(0);e.exports=function(e,t){r.forEach(e,function(n,r){r!==t&&r.toUpperCase()===t.toUpperCase()&&(e[t]=n,delete e[r])})}},function(e,t,n){"use strict";var r=n(4);e.exports=function(e,t,n){var o=n.config.validateStatus;n.status&&o&&!o(n.status)?t(r("Request failed with status code "+n.status,n.config,null,n.request,n)):e(n)}},function(e,t,n){"use strict";e.exports=function(e,t,n,r,o){return e.config=t,n&&(e.code=n),e.request=r,e.response=o,e}},function(e,t,n){"use strict";var r=n(0);function o(e){return encodeURIComponent(e).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}e.exports=function(e,t,n){if(!t)return e;var i;if(n)i=n(t);else if(r.isURLSearchParams(t))i=t.toString();else{var s=[];r.forEach(t,function(e,t){null!==e&&void 0!==e&&(r.isArray(e)?t+="[]":e=[e],r.forEach(e,function(e){r.isDate(e)?e=e.toISOString():r.isObject(e)&&(e=JSON.stringify(e)),s.push(o(t)+"="+o(e))}))}),i=s.join("&")}return i&&(e+=(-1===e.indexOf("?")?"?":"&")+i),e}},function(e,t,n){"use strict";var r=n(0),o=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];e.exports=function(e){var t,n,i,s={};return e?(r.forEach(e.split("\n"),function(e){if(i=e.indexOf(":"),t=r.trim(e.substr(0,i)).toLowerCase(),n=r.trim(e.substr(i+1)),t){if(s[t]&&o.indexOf(t)>=0)return;s[t]="set-cookie"===t?(s[t]?s[t]:[]).concat([n]):s[t]?s[t]+", "+n:n}}),s):s}},function(e,t,n){"use strict";var r=n(0);e.exports=r.isStandardBrowserEnv()?function(){var e,t=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");function o(e){var r=e;return t&&(n.setAttribute("href",r),r=n.href),n.setAttribute("href",r),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:"/"===n.pathname.charAt(0)?n.pathname:"/"+n.pathname}}return e=o(window.location.href),function(t){var n=r.isString(t)?o(t):t;return n.protocol===e.protocol&&n.host===e.host}}():function(){return!0}},function(e,t,n){"use strict";function r(){this.message="String contains an invalid character"}r.prototype=new Error,r.prototype.code=5,r.prototype.name="InvalidCharacterError",e.exports=function(e){for(var t,n,o=String(e),i="",s=0,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";o.charAt(0|s)||(a="=",s%1);i+=a.charAt(63&t>>8-s%1*8)){if((n=o.charCodeAt(s+=.75))>255)throw new r;t=t<<8|n}return i}},function(e,t,n){"use strict";var r=n(0);e.exports=r.isStandardBrowserEnv()?{write:function(e,t,n,o,i,s){var a=[];a.push(e+"="+encodeURIComponent(t)),r.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),r.isString(o)&&a.push("path="+o),r.isString(i)&&a.push("domain="+i),!0===s&&a.push("secure"),document.cookie=a.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(e,t,n){"use strict";var r=n(0);function o(){this.handlers=[]}o.prototype.use=function(e,t){return this.handlers.push({fulfilled:e,rejected:t}),this.handlers.length-1},o.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)},o.prototype.forEach=function(e){r.forEach(this.handlers,function(t){null!==t&&e(t)})},e.exports=o},function(e,t,n){"use strict";var r=n(0),o=n(23),i=n(5),s=n(1),a=n(24),u=n(25);function c(e){e.cancelToken&&e.cancelToken.throwIfRequested()}e.exports=function(e){return c(e),e.baseURL&&!a(e.url)&&(e.url=u(e.baseURL,e.url)),e.headers=e.headers||{},e.data=o(e.data,e.headers,e.transformRequest),e.headers=r.merge(e.headers.common||{},e.headers[e.method]||{},e.headers||{}),r.forEach(["delete","get","head","post","put","patch","common"],function(t){delete e.headers[t]}),(e.adapter||s.adapter)(e).then(function(t){return c(e),t.data=o(t.data,t.headers,e.transformResponse),t},function(t){return i(t)||(c(e),t&&t.response&&(t.response.data=o(t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)})}},function(e,t,n){"use strict";var r=n(0);e.exports=function(e,t,n){return r.forEach(n,function(n){e=n(e,t)}),e}},function(e,t,n){"use strict";e.exports=function(e){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)}},function(e,t,n){"use strict";e.exports=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}},function(e,t,n){"use strict";var r=n(6);function o(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");var t;this.promise=new Promise(function(e){t=e});var n=this;e(function(e){n.reason||(n.reason=new r(e),t(n.reason))})}o.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},o.source=function(){var e;return{token:new o(function(t){e=t}),cancel:e}},e.exports=o},function(e,t,n){"use strict";e.exports=function(e){return function(t){return e.apply(null,t)}}}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJtaTE4bi5taW4uanMiLCJzb3VyY2VSb290IjoiIn0=

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return remove; });
/* unused harmony export closest */
/* unused harmony export closestFtype */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return componentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return unique; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return uuid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return percent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return numToPercent; });
/* unused harmony export numberBetween */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cleanObj; });
/* unused harmony export clicked */
/* unused harmony export memoize */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return sessionStorage; });
/* unused harmony export escapeHtml */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isExternalAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isBoolKey; });
/* unused harmony export typeIsChildOf */
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var uuid_v4__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uuid_v4__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);
/* harmony import */ var lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2__);



var match = function match(str, filter) {
  if (str === void 0) {
    str = '';
  }

  if (!filter) {
    console.warn('utils.match missing argument 2.');
    return false;
  }

  var matchOperators = /[|\\{}()[\]^*$+?.]/g;
  var filterArray = typeof filter === 'string' ? [filter] : filter;
  filterArray = filterArray.map(function (filterStr) {
    return filterStr === '*' ? '' : filterStr.replace(matchOperators, '\\$&');
  });
  var isMatch = true;

  if (filterArray.length) {
    isMatch = !str.match(new RegExp(filterArray.join('|'), 'i'));
  }

  return isMatch;
};
var remove = function remove(arr, val) {
  var index = arr.indexOf(val);

  if (index !== -1) {
    arr.splice(index, 1);
  }
};
var closest = function closest(el, cls) {
  var className = cls.replace('.', '');

  while ((el = el.parentElement) && !el.classList.contains(className)) {
    ;
  }

  return el;
};
var closestFtype = function closestFtype(el) {
  while ((el = el.parentElement) && !componentType(el)) {
    ;
  }

  return el;
};
var componentType = function componentType(node) {
  var classMatch = node.className && node.className.match(_constants__WEBPACK_IMPORTED_MODULE_1__[/* COMPONENT_TYPE_CLASSNAMES_REGEXP */ "l"]);
  return classMatch && _constants__WEBPACK_IMPORTED_MODULE_1__[/* COMPONENT_TYPE_CLASSNAMES_LOOKUP */ "k"][classMatch[0]];
};
var unique = function unique(array) {
  return Array.from(new Set(array));
};
var uuid = function uuid(elem) {
  var id;

  if (elem) {
    var _elem$attrs = elem.attrs,
        attrs = _elem$attrs === void 0 ? {} : _elem$attrs;
    id = attrs.id || elem.id || uuid_v4__WEBPACK_IMPORTED_MODULE_0___default()();
    elem.id = id;
  } else {
    id = uuid_v4__WEBPACK_IMPORTED_MODULE_0___default()();
  }

  return id;
};
var merge = function merge(obj1, obj2, opts) {
  if (opts === void 0) {
    opts = Object.create(null);
  }

  var customizer = function customizer(objValue, srcValue) {
    if (Array.isArray(objValue)) {
      if (Array.isArray(srcValue)) {
        return unique(opts.mergeArray ? objValue.concat(srcValue) : srcValue);
      } else {
        return srcValue;
      }
    }
  };

  return lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2___default()({}, obj1, obj2, customizer);
};
var clone = function clone(obj) {
  var copy;

  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (obj instanceof Date) {
    copy = new Date();
    copy.setTime(obj.getTime());
    return copy;
  }

  if (obj instanceof Array) {
    copy = [];

    for (var i = 0, len = obj.length; i < len; i++) {
      copy[i] = clone(obj[i]);
    }

    return copy;
  }

  if (obj instanceof Object) {
    copy = {};

    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) {
        copy[attr] = clone(obj[attr]);
      }
    }

    return copy;
  }

  throw new Error('Unable to copy Object, type not supported.');
};
var percent = function percent(val, total) {
  return val / total * 100;
};
var numToPercent = function numToPercent(num) {
  return num.toString() + '%';
};
var numberBetween = function numberBetween(num, min, max) {
  return num > min && num < max;
};
var cleanObj = function cleanObj(obj) {
  var fresh = Object.assign({}, obj);
  var typeMap = {
    string: function string() {
      return '';
    },
    boolean: function boolean() {
      return false;
    },
    object: function object(val) {
      return cleanObj(val);
    }
  };
  Object.keys(obj).forEach(function (key) {
    var valType = typeof obj[key];

    if (typeMap[valType]) {
      fresh[key] = typeMap[valType](obj[key]);
    }
  });
  return fresh;
};
var clicked = function clicked(x, y, position, button) {
  var xMin = position.x - 5;
  var xMax = position.x + 5;
  var yMin = position.y - 5;
  var yMax = position.y + 5;
  var xOK = numberBetween(x, xMin, xMax);
  var yOK = numberBetween(y, yMin, yMax);
  return xOK && yOK && button !== 2;
};
var memoize = function memoize(fn, resolver) {
  if (typeof fn !== 'function' || resolver && typeof resolver !== 'function') {
    throw new TypeError('memoize: First argument must be a function');
  }

  var memoized = function memoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var key = resolver ? resolver.apply(memoized, args) : args[0];
    var cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = fn.apply(memoized, args);
    memoized.cache = cache.set(key, result);
    return result;
  };

  memoized.cache = new Map();
  return memoized;
};
var sessionStorage = Object.create(null, {
  get: {
    value: function value(key) {
      var itemValue = window.sessionStorage && window.sessionStorage.getItem(key);

      try {
        return JSON.parse(itemValue);
      } catch (error) {
        console.error(error);
      }
    }
  },
  set: {
    value: function value(key, itemValue) {
      try {
        return window.sessionStorage && window.sessionStorage.setItem(key, JSON.stringify(itemValue));
      } catch (error) {
        console.error(error);
      }
    }
  }
});
var escapeHtml = function escapeHtml(html) {
  var escapeElement = document.createElement('textarea');
  escapeElement.textContent = html;
  return escapeElement.innerHTML;
};
var isAddress = function isAddress(str) {
  return _constants__WEBPACK_IMPORTED_MODULE_1__[/* COMPONENT_INDEX_TYPES */ "i"].some(function (indexType) {
    return new RegExp("^" + indexType + ".").test(str);
  });
};
var isExternalAddress = function isExternalAddress(str) {
  return /^external/.test(str);
};
var isBoolKey = function isBoolKey(key) {
  return /^is|^has/.test(key);
};
var typeIsChildOf = function typeIsChildOf(childType, parentType) {
  return _constants__WEBPACK_IMPORTED_MODULE_1__[/* CHILD_TYPE_MAP */ "f"].get(parentType) === childType;
};

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return indexOfNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return orderObjectsBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return forEach; });
/* unused harmony export camelCase */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hyphenCase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return map; });
/* unused harmony export safeAttrName */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return capitalize; });
/* unused harmony export copyObj */
/* unused harmony export subtract */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isIE; });
/* unused harmony export helpers */
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_camelCase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(89);
/* harmony import */ var lodash_camelCase__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_camelCase__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_lowerCase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
/* harmony import */ var lodash_lowerCase__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_lowerCase__WEBPACK_IMPORTED_MODULE_4__);







var isInt = function isInt(n) {
  return Number.isInteger(Number(n));
};
var indexOfNode = function indexOfNode(node, parent) {
  var parentElement = parent || node.parentElement;
  var nodeList = Array.prototype.slice.call(parentElement.childNodes);
  return nodeList.indexOf(node);
};
var orderObjectsBy = function orderObjectsBy(elements, order, path) {
  var splitPath = path.split('||');
  var newOrder = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* unique */ "m"])(order).map(function (key) {
    return elements.find(function (elem) {
      var newPath = splitPath.find(function (p) {
        return !!get(elem, p);
      });
      return newPath && get(elem, newPath) === key;
    });
  }).filter(Boolean);
  var orderedElements = newOrder.concat(elements);
  return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* unique */ "m"])(orderedElements);
};
var get = lodash_get__WEBPACK_IMPORTED_MODULE_2___default.a;
var set = lodash_set__WEBPACK_IMPORTED_MODULE_1___default.a;
var forEach = function forEach(arr, cb, scope) {
  for (var i = 0; i < arr.length; i++) {
    cb.call(scope, arr[i], i);
  }
};
var camelCase = lodash_camelCase__WEBPACK_IMPORTED_MODULE_3___default.a;
var hyphenCase = function hyphenCase(str) {
  return lodash_lowerCase__WEBPACK_IMPORTED_MODULE_4___default()(str).replace(/\s/g, '-');
};
var map = function map(arr, cb) {
  var newArray = [];
  forEach(arr, function (elem, i) {
    return newArray.push(cb(elem, i));
  });
  return newArray;
};
var safeAttrName = function safeAttrName(name) {
  var safeAttr = {
    className: 'class'
  };
  return safeAttr[name] || hyphenCase(name);
};
var capitalize = function capitalize(str) {
  return str.replace(/\b\w/g, function (m) {
    return m.toUpperCase();
  });
};
var copyObj = function copyObj(obj) {
  return window.JSON.parse(window.JSON.stringify(obj));
};
var subtract = function subtract(arr, from) {
  return from.filter(function (a) {
    return !~arr.indexOf(a);
  });
};
var isIE = function isIE() {
  return window.navigator.userAgent.indexOf('MSIE ') !== -1;
};
var helpers = {
  hyphenCase: hyphenCase,
  capitalize: capitalize,
  safeAttrName: safeAttrName,
  forEach: forEach,
  copyObj: copyObj,
  map: map,
  subtract: subtract,
  indexOfNode: indexOfNode,
  isInt: isInt,
  get: get,
  set: set,
  orderObjectsBy: orderObjectsBy,
  isIE: isIE
};
/* harmony default export */ __webpack_exports__["b"] = (helpers);

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../src/js/components/data.js
var components_data = __webpack_require__(21);

// EXTERNAL MODULE: ../src/js/common/utils.js
var utils = __webpack_require__(3);

// EXTERNAL MODULE: ../src/js/components/controls/index.js + 21 modules
var controls = __webpack_require__(12);

// EXTERNAL MODULE: ../src/js/common/helpers.js
var helpers = __webpack_require__(4);

// CONCATENATED MODULE: ../src/js/components/component-data.js
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var component_data_ComponentData = function (_Data) {
  _inheritsLoose(ComponentData, _Data);

  function ComponentData() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Data.call.apply(_Data, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "load", function (data) {
      if (data === void 0) {
        data = Object.create(null);
      }

      _this.empty();

      if (typeof data === 'string') {
        data = JSON.parse(data);
      }

      Object.entries(data).forEach(function (_ref) {
        var key = _ref[0],
            val = _ref[1];
        return _this.add(key, val);
      });
      return _this.data;
    });

    _defineProperty(_assertThisInitialized(_this), "get", function (path) {
      return path ? Object(helpers["d" /* get */])(_this.data, path) : _this.add();
    });

    _defineProperty(_assertThisInitialized(_this), "add", function (id, data) {
      if (data === void 0) {
        data = Object.create(null);
      }

      var elemId = id || Object(utils["n" /* uuid */])();

      var component = _this.Component(Object.assign({}, data, {
        id: elemId
      }));

      _this.set(elemId, component);

      _this.active = component;
      return component;
    });

    _defineProperty(_assertThisInitialized(_this), "remove", function (componentId) {
      if (Array.isArray(componentId)) {
        componentId.forEach(function (id) {
          _this.get(id).remove();
        });
      } else {
        _this.get(componentId).remove();
      }

      return _this.data;
    });

    _defineProperty(_assertThisInitialized(_this), "delete", function (componentId) {
      delete _this.data[componentId];
      return componentId;
    });

    _defineProperty(_assertThisInitialized(_this), "clearAll", function (isAnimated) {
      if (isAnimated === void 0) {
        isAnimated = true;
      }

      var promises = Object.values(_this.data).map(function (component) {
        return component.empty(isAnimated);
      });
      return Promise.all(promises);
    });

    _defineProperty(_assertThisInitialized(_this), "conditionMap", new Map());

    return _this;
  }

  _createClass(ComponentData, [{
    key: "config",
    set: function set(config) {
      this.configVal = Object(utils["h" /* merge */])(this.configVal, Object(utils["b" /* clone */])(config));
      return this.configVal;
    },
    get: function get() {
      return this.configVal;
    }
  }]);

  return ComponentData;
}(components_data["a" /* default */]);


// EXTERNAL MODULE: ../node_modules/sortablejs/modular/sortable.esm.js
var sortable_esm = __webpack_require__(14);

// EXTERNAL MODULE: ../src/js/common/dom.js
var dom = __webpack_require__(0);

// EXTERNAL MODULE: ../src/js/components/component.js
var components_component = __webpack_require__(15);

// EXTERNAL MODULE: ../src/js/constants.js
var constants = __webpack_require__(1);

// EXTERNAL MODULE: ../src/js/common/animation.js
var animation = __webpack_require__(7);

// CONCATENATED MODULE: ../src/js/components/stages/stage.js
function stage_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function stage_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }








var stage_DEFAULT_DATA = function DEFAULT_DATA() {
  return Object.freeze({
    children: []
  });
};

var stage_Stage = function (_Component) {
  stage_inheritsLoose(Stage, _Component);

  function Stage(stageData, render) {
    var _this;

    _this = _Component.call(this, 'stage', Object.assign({}, stage_DEFAULT_DATA(), stageData), render) || this;

    var children = _this.createChildWrap();

    _this.dom = dom["a" /* default */].create({
      attrs: {
        className: [constants["H" /* STAGE_CLASSNAME */], 'empty'],
        id: _this.id
      },
      children: children
    });
    _this.sortable = sortable_esm["a" /* default */].create(children, {
      animation: 150,
      fallbackClass: 'row-moving',
      forceFallback: true,
      group: {
        name: 'stage',
        pull: true,
        put: ['row', 'column', 'controls']
      },
      sort: true,
      disabled: false,
      onAdd: _this.onAdd.bind(stage_assertThisInitialized(_this)),
      onRemove: _this.onRemove.bind(stage_assertThisInitialized(_this)),
      onStart: function onStart() {
        return components_stages.active = stage_assertThisInitialized(_this);
      },
      onSort: _this.onSort.bind(stage_assertThisInitialized(_this)),
      draggable: "." + constants["E" /* ROW_CLASSNAME */],
      handle: '.item-handle'
    });
    return _this;
  }

  var _proto = Stage.prototype;

  _proto.empty = function empty(isAnimated) {
    var _this2 = this;

    if (isAnimated === void 0) {
      isAnimated = true;
    }

    return new Promise(function (resolve) {
      if (isAnimated) {
        _this2.dom.classList.add('removing-all-fields');

        animation["a" /* default */].slideUp(_this2.dom, constants["a" /* ANIMATION_SPEED_BASE */], function () {
          resolve(_Component.prototype.empty.call(_this2, isAnimated));

          _this2.dom.classList.remove('removing-all-fields');

          animation["a" /* default */].slideDown(_this2.dom, constants["a" /* ANIMATION_SPEED_BASE */]);
        });
      } else {
        resolve(_Component.prototype.empty.call(_this2));
      }
    });
  };

  _proto.onAdd = function onAdd() {
    var _Component$prototype$;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var component = (_Component$prototype$ = _Component.prototype.onAdd).call.apply(_Component$prototype$, [this].concat(args));

    if (component && component.name === 'column') {
      component.parent.autoColumnWidths();
    }
  };

  return Stage;
}(components_component["a" /* default */]);


// CONCATENATED MODULE: ../src/js/components/stages/index.js
function stages_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var stages_Stages = function (_ComponentData) {
  stages_inheritsLoose(Stages, _ComponentData);

  function Stages(stageData) {
    return _ComponentData.call(this, 'stages', stageData) || this;
  }

  var _proto = Stages.prototype;

  _proto.Component = function Component(data) {
    return new stage_Stage(data);
  };

  return Stages;
}(component_data_ComponentData);
var stages_stages = new stages_Stages();
/* harmony default export */ var components_stages = (stages_stages);
// EXTERNAL MODULE: ../node_modules/mi18n/dist/mi18n.min.js
var mi18n_min = __webpack_require__(2);
var mi18n_min_default = /*#__PURE__*/__webpack_require__.n(mi18n_min);

// EXTERNAL MODULE: ../src/js/common/events.js
var events = __webpack_require__(6);

// CONCATENATED MODULE: ../src/js/components/columns/events.js





var CUSTOM_COLUMN_OPTION_CLASSNAME = 'custom-column-widths';
var COLUMN_PRESET_CLASSNAME = 'column-preset';
var COLUMN_RESIZE_CLASSNAME = 'resizing-columns';
function events_resize(evt) {
  var resize = this;
  var column = evt.target.parentElement;
  var sibling = column.nextSibling || column.previousSibling;
  var row = column.closest("." + constants["E" /* ROW_CLASSNAME */]);
  var rowStyle = dom["a" /* default */].getStyle(row);
  var rowPadding = parseFloat(rowStyle.paddingLeft) + parseFloat(rowStyle.paddingRight);
  evt.target.removeEventListener('pointerdown', resize);

  resize.move = function (_ref) {
    var touches = _ref.touches,
        type = _ref.type,
        clientX = _ref.clientX;

    if (type === 'touchmove') {
      var firstTouch = touches[0];
      clientX = firstTouch.clientX;
    }

    var newColWidth = resize.colStartWidth + clientX - resize.startX;
    var newSibWidth = resize.sibStartWidth - clientX + resize.startX;
    var colWidthPercent = parseFloat(Object(utils["j" /* percent */])(newColWidth, resize.rowWidth));
    var sibWidthPercent = parseFloat(Object(utils["j" /* percent */])(newSibWidth, resize.rowWidth));
    var colWidth = Object(utils["i" /* numToPercent */])(colWidthPercent.toFixed(1));
    var siblingColWidth = Object(utils["i" /* numToPercent */])(sibWidthPercent.toFixed(1));
    column.dataset.colWidth = colWidth;
    sibling.dataset.colWidth = siblingColWidth;
    column.style.width = colWidth;
    sibling.style.width = siblingColWidth;
    resize.resized = true;
  };

  resize.stop = function () {
    window.removeEventListener('pointermove', resize.move);
    window.removeEventListener('pointerup', resize.stop);
    window.removeEventListener('touchmove', resize.move);
    window.removeEventListener('touchend', resize.stop);

    if (!resize.resized) {
      return;
    }

    events_setCustomWidthValue(row, resize.rowWidth);
    row.classList.remove(COLUMN_RESIZE_CLASSNAME);
    js_components.setAddress("columns." + column.id + ".config.width", column.dataset.colWidth);
    js_components.setAddress("columns." + sibling.id + ".config.width", sibling.dataset.colWidth);
    resize.resized = false;
  };

  if (evt.type === 'touchstart') {
    var _evt$touches = evt.touches,
        firstTouch = _evt$touches[0];
    resize.startX = firstTouch.clientX;
  } else {
    resize.startX = evt.clientX;
  }

  row.classList.add(COLUMN_RESIZE_CLASSNAME);
  column.className.replace(constants["J" /* bsColRegExp */], '');
  sibling.className.replace(constants["J" /* bsColRegExp */], '');
  resize.colStartWidth = column.offsetWidth || dom["a" /* default */].getStyle(column, 'width');
  resize.sibStartWidth = sibling.offsetWidth || dom["a" /* default */].getStyle(sibling, 'width');
  resize.rowWidth = row.offsetWidth - rowPadding;
  window.addEventListener('pointerup', resize.stop, false);
  window.addEventListener('pointermove', resize.move, false);
  window.addEventListener('touchend', resize.stop, false);
  window.addEventListener('touchmove', resize.move, false);
}
var removeCustomOption = function removeCustomOption(row, columnPreset) {
  if (columnPreset === void 0) {
    columnPreset = row.querySelector("." + COLUMN_PRESET_CLASSNAME);
  }

  var customOption = columnPreset.querySelector("." + CUSTOM_COLUMN_OPTION_CLASSNAME);
  return customOption && columnPreset.removeChild(customOption);
};
var events_setCustomWidthValue = function setCustomWidthValue(row, rowWidth) {
  var columnPreset = row.querySelector("." + COLUMN_PRESET_CLASSNAME);
  var customOption = columnPreset.querySelector("." + CUSTOM_COLUMN_OPTION_CLASSNAME);
  var cols = row.querySelector('.children').children;
  var widths = Object(helpers["i" /* map */])(cols, function (col) {
    return Object(utils["j" /* percent */])(col.clientWidth, rowWidth).toFixed(1);
  });
  var value = widths.join(',');
  var content = widths.join(' | ');

  if (customOption) {
    removeCustomOption(row, columnPreset);
  }

  var newCustomOption = dom["a" /* default */].create({
    tag: 'option',
    attrs: {
      className: CUSTOM_COLUMN_OPTION_CLASSNAME,
      value: value
    },
    content: content
  });
  columnPreset.add(newCustomOption);
  columnPreset.value = value;
  return value;
};
// CONCATENATED MODULE: ../src/js/components/rows/row.js
function row_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function row_createClass(Constructor, protoProps, staticProps) { if (protoProps) row_defineProperties(Constructor.prototype, protoProps); if (staticProps) row_defineProperties(Constructor, staticProps); return Constructor; }

function row_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function row_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function row_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var row_DEFAULT_DATA = function DEFAULT_DATA() {
  return Object.freeze({
    config: {
      fieldset: false,
      legend: '',
      inputGroup: false
    },
    children: [],
    className: [constants["E" /* ROW_CLASSNAME */]]
  });
};

var row_Row = function (_Component) {
  row_inheritsLoose(Row, _Component);

  function Row(rowData) {
    var _this2;

    _this2 = _Component.call(this, 'row', Object.assign({}, row_DEFAULT_DATA(), rowData)) || this;

    row_defineProperty(row_assertThisInitialized(_this2), "autoColumnWidths", function () {
      var columns = _this2.children;

      if (!columns.length) {
        return;
      }

      var width = parseFloat((100 / columns.length).toFixed(1)) / 1;
      columns.forEach(function (column) {
        column.removeClasses(constants["J" /* bsColRegExp */]);
        var colDom = column.dom;
        var newColWidth = Object(utils["i" /* numToPercent */])(width);
        column.set('config.width', newColWidth);
        colDom.style.width = newColWidth;
        colDom.dataset.colWidth = newColWidth;
        var refreshTimeout = setTimeout(function () {
          clearTimeout(refreshTimeout);
          column.refreshFieldPanels();
        }, constants["b" /* ANIMATION_SPEED_FAST */]);
        document.dispatchEvent(events["a" /* default */].columnResized);
      });

      _this2.updateColumnPreset();
    });

    row_defineProperty(row_assertThisInitialized(_this2), "updateColumnPreset", function () {
      var oldColumnPreset = _this2.dom.querySelector('.column-preset');

      var rowEdit = oldColumnPreset.parentElement;

      var columnPresetConfig = _this2.columnPresetControl(_this2.id);

      var newColumnPreset = dom["a" /* default */].create(columnPresetConfig);
      rowEdit.replaceChild(newColumnPreset, oldColumnPreset);
      return columnPresetConfig;
    });

    row_defineProperty(row_assertThisInitialized(_this2), "setColumnWidths", function (widths) {
      if (widths === 'custom') {
        return;
      }

      if (typeof widths === 'string') {
        widths = widths.split(',');
      }

      _this2.children.forEach(function (column, i) {
        column.setWidth(widths[i] + "%");
        column.refreshFieldPanels();
      });
    });

    row_defineProperty(row_assertThisInitialized(_this2), "columnPresetControl", function () {
      var _this = row_assertThisInitialized(_this2);

      var layoutPreset = {
        tag: 'select',
        attrs: {
          ariaLabel: mi18n_min_default.a.get('defineColumnLayout'),
          className: 'column-preset'
        },
        action: {
          change: function change(_ref) {
            var value = _ref.target.value;

            if (value !== 'custom') {
              removeCustomOption(_this2.dom);

              _this.setColumnWidths(value);
            }
          }
        },
        options: []
      };
      var pMap = constants["h" /* COLUMN_TEMPLATES */];
      var columns = _this2.children;
      var pMapVal = pMap.get(columns.length - 1) || [];
      var curVal = columns.map(function (Column) {
        var width = Column.get('config.width') || '';
        return Number(width.replace('%', '')).toFixed(1);
      }).join(',');

      if (pMapVal.length) {
        var options = pMapVal.slice();
        var isCustomVal = !options.find(function (val) {
          return val.value === curVal;
        });

        if (isCustomVal) {
          options.push({
            value: curVal,
            label: curVal.replace(/,/g, ' | '),
            className: 'custom-column-widths'
          });
        }

        layoutPreset.options = options.map(function (val) {
          var option = Object.assign({}, val);

          if (val.value === curVal) {
            option.selected = true;
          }

          return option;
        });
      }

      return layoutPreset;
    });

    var children = _this2.createChildWrap();

    _this2.dom = dom["a" /* default */].create({
      tag: 'li',
      className: [constants["E" /* ROW_CLASSNAME */], 'empty'],
      dataset: {
        hoverTag: mi18n_min_default.a.get('row'),
        editingHoverTag: mi18n_min_default.a.get('editing.row')
      },
      id: _this2.id,
      content: [_this2.getActionButtons(), _this2.editWindow, children]
    });
    _this2.sortable = sortable_esm["a" /* default */].create(children, {
      animation: 150,
      fallbackClass: 'column-moving',
      forceFallback: true,
      group: {
        name: 'row',
        pull: true,
        put: ['row', 'column', 'controls']
      },
      sort: true,
      disabled: false,
      onRemove: _this2.onRemove.bind(row_assertThisInitialized(_this2)),
      onEnd: _this2.onEnd.bind(row_assertThisInitialized(_this2)),
      onAdd: _this2.onAdd.bind(row_assertThisInitialized(_this2)),
      onSort: _this2.onSort.bind(row_assertThisInitialized(_this2)),
      filter: '.resize-x-handle',
      draggable: "." + constants["g" /* COLUMN_CLASSNAME */],
      handle: '.item-handle'
    });

    _this2.onRender();

    return _this2;
  }

  var _proto = Row.prototype;

  _proto.onAdd = function onAdd() {
    var _Component$prototype$;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (_Component$prototype$ = _Component.prototype.onAdd).call.apply(_Component$prototype$, [this].concat(args));

    this.autoColumnWidths();
  };

  _proto.onRemove = function onRemove() {
    var _Component$prototype$2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    (_Component$prototype$2 = _Component.prototype.onRemove).call.apply(_Component$prototype$2, [this].concat(args));

    this.autoColumnWidths();
  };

  row_createClass(Row, [{
    key: "editWindow",
    get: function get() {
      var _this3 = this;

      var _this = this;

      var editWindow = {
        className: this.name + "-edit group-config"
      };
      var classLabel = {
        tag: 'label',
        content: mi18n_min_default.a.get('class'),
        className: 'col-sm-4 form-control-label'
      };
      var classInput = {
        tag: 'input',
        attrs: {
          type: 'text',
          ariaLabel: 'Class for column',
          value: _this.get('attrs.className'),
          placeholder: mi18n_min_default.a.get('class')
        },
        action: {
          input: function input(_ref2) {
            var value = _ref2.target.value;
            return _this.set('attrs.className', value);
          }
        },
        className: ''
      };
      var fieldsetLabel = {
        tag: 'label',
        content: mi18n_min_default.a.get('row.settings.fieldsetWrap')
      };
      var fieldsetInput = {
        tag: 'input',
        id: _this.id + '-fieldset',
        attrs: {
          type: 'checkbox',
          checked: this.get('config.fieldset'),
          ariaLabel: mi18n_min_default.a.get('row.settings.fieldsetWrap.aria')
        },
        action: {
          click: function click(_ref3) {
            var checked = _ref3.target.checked;

            _this3.set('config.fieldset', Boolean(checked));
          }
        }
      };
      var inputGroupInput = {
        tag: 'input',
        id: this.id + "-inputGroup",
        attrs: {
          type: 'checkbox',
          checked: this.get('config.inputGroup'),
          ariaLabel: mi18n_min_default.a.get('row.settings.inputGroup.aria')
        },
        action: {
          click: function click(_ref4) {
            var checked = _ref4.target.checked;
            return _this3.set('config.inputGroup', checked);
          }
        },
        config: {
          label: mi18n_min_default.a.get('row.makeInputGroup'),
          description: mi18n_min_default.a.get('row.makeInputGroupDesc')
        }
      };
      var inputAddon = {
        tag: 'span',
        className: 'input-group-addon',
        content: fieldsetInput
      };
      var legendInput = {
        tag: 'input',
        attrs: {
          type: 'text',
          ariaLabel: 'Legend for fieldset',
          value: _this.get('config.legend'),
          placeholder: 'Legend'
        },
        action: {
          input: function input(_ref5) {
            var value = _ref5.target.value;
            return _this.set('config.legend', value);
          }
        },
        className: ''
      };
      var fieldsetInputGroup = {
        className: 'input-group',
        content: [inputAddon, legendInput]
      };
      var fieldSetControls = dom["a" /* default */].formGroup([fieldsetLabel, fieldsetInputGroup]);
      var columnSettingsPresetLabel = {
        tag: 'label',
        content: mi18n_min_default.a.get('defineColumnWidths'),
        className: 'col-sm-4 form-control-label'
      };
      var columnSettingsPresetSelect = {
        className: 'col-sm-8',
        content: {
          className: 'column-preset'
        },
        action: {
          onRender: function onRender(evt) {
            _this3.updateColumnPreset();
          }
        }
      };
      var columnSettingsPreset = dom["a" /* default */].formGroup([columnSettingsPresetLabel, columnSettingsPresetSelect], 'row');
      editWindow.children = [classLabel, classInput, dom["a" /* default */].create('hr'), inputGroupInput, dom["a" /* default */].create('hr'), fieldSetControls, dom["a" /* default */].create('hr'), columnSettingsPreset];
      return editWindow;
    }
  }]);

  return Row;
}(components_component["a" /* default */]);


// CONCATENATED MODULE: ../src/js/components/rows/index.js
function rows_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var DEFAULT_CONFIG = {
  actionButtons: {
    buttons: ['handle', 'edit', 'clone', 'remove'],
    disabled: []
  }
};
var rows_Rows = function (_ComponentData) {
  rows_inheritsLoose(Rows, _ComponentData);

  function Rows(rowData) {
    var _this;

    _this = _ComponentData.call(this, 'rows', rowData) || this;
    _this.config = {
      all: DEFAULT_CONFIG
    };
    return _this;
  }

  var _proto = Rows.prototype;

  _proto.Component = function Component(data) {
    return new row_Row(data);
  };

  return Rows;
}(component_data_ComponentData);
var rows_rows = new rows_Rows();
/* harmony default export */ var components_rows = (rows_rows);
// CONCATENATED MODULE: ../src/js/components/columns/column.js
function column_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function column_createClass(Constructor, protoProps, staticProps) { if (protoProps) column_defineProperties(Constructor.prototype, protoProps); if (staticProps) column_defineProperties(Constructor, staticProps); return Constructor; }

function column_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function column_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function column_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var column_DEFAULT_DATA = function DEFAULT_DATA() {
  return Object.freeze({
    config: {
      width: '100%',
      className: ''
    },
    children: [],
    className: constants["g" /* COLUMN_CLASSNAME */]
  });
};

var DOM_CONFIGS = {
  resizeHandle: function resizeHandle() {
    return {
      className: 'resize-x-handle',
      action: {
        pointerdown: events_resize
      },
      content: [dom["a" /* default */].icon('triangle-down'), dom["a" /* default */].icon('triangle-up')]
    };
  }
};

var column_Column = function (_Component) {
  column_inheritsLoose(Column, _Component);

  function Column(columnData) {
    var _this2;

    _this2 = _Component.call(this, 'column', Object.assign({}, column_DEFAULT_DATA(), columnData)) || this;

    column_defineProperty(column_assertThisInitialized(_this2), "fieldOrderClasses", function () {
      var fields = _this2.children.map(function (_ref) {
        var dom = _ref.dom;
        return dom;
      });

      if (fields.length) {
        _this2.removeClasses(['first-field', 'last-field']);

        fields[0].classList.add('first-field');
        fields[fields.length - 1].classList.add('last-field');
      }
    });

    column_defineProperty(column_assertThisInitialized(_this2), "refreshFieldPanels", function () {
      _this2.children.forEach(function (field) {
        return field.panels.nav.refresh();
      });
    });

    column_defineProperty(column_assertThisInitialized(_this2), "setWidth", function (width) {
      _this2.dom.dataset.colWidth = width;
      _this2.dom.style.width = width;
      return _this2.set('config.width', width);
    });

    var _this = column_assertThisInitialized(_this2);

    var children = _this2.createChildWrap();

    _this2.dom = dom["a" /* default */].create({
      tag: 'li',
      className: [constants["g" /* COLUMN_CLASSNAME */], 'empty'],
      dataset: {
        hoverTag: mi18n_min_default.a.get('column')
      },
      action: {
        mouseup: function mouseup(evt) {
          var column = evt.target.parentElement;

          if (column.resizing) {
            column.resizing = false;
            column.parentElement.classList.remove('resizing-columns');
          }
        }
      },
      id: _this2.id,
      content: [_this2.getActionButtons(), _this2.editWindow, DOM_CONFIGS.resizeHandle(), children]
    });

    _this2.processConfig(_this2.dom);

    events["a" /* default */].columnResized = new window.CustomEvent('columnResized', {
      detail: {
        column: _this2.dom,
        instance: _this
      }
    });
    _this2.sortable = sortable_esm["a" /* default */].create(children, {
      animation: 150,
      fallbackClass: 'field-moving',
      forceFallback: true,
      group: {
        name: 'column',
        pull: true,
        put: ['column', 'controls']
      },
      sort: true,
      disabled: false,
      onEnd: _this2.onEnd.bind(column_assertThisInitialized(_this2)),
      onAdd: _this2.onAdd.bind(column_assertThisInitialized(_this2)),
      onSort: _this2.onSort.bind(column_assertThisInitialized(_this2)),
      onRemove: _this2.onRemove.bind(column_assertThisInitialized(_this2)),
      onMove: function onMove(evt) {
        if (evt.from !== evt.to) {
          evt.from.classList.remove('hovering-column');
        }
      },
      draggable: "." + constants["z" /* FIELD_CLASSNAME */],
      handle: '.item-handle'
    });
    return _this2;
  }

  var _proto = Column.prototype;

  _proto.processConfig = function processConfig(column) {
    var columnWidth = helpers["b" /* default */].get(this.data, 'config.width');

    if (columnWidth) {
      column.dataset.colWidth = columnWidth;
      column.style.width = columnWidth;
      column.style.float = 'left';
    }
  };

  _proto.addChild = function addChild() {
    var _Component$prototype$;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (_Component$prototype$ = _Component.prototype.addChild).call.apply(_Component$prototype$, [this].concat(args));

    this.fieldOrderClasses();
  };

  column_createClass(Column, [{
    key: "editWindow",
    get: function get() {
      var _this = this;

      var editWindow = {
        className: this.name + "-edit group-config"
      };
      var classLabel = {
        tag: 'label',
        content: mi18n_min_default.a.get('class'),
        className: 'col-sm-4 form-control-label'
      };
      var classInput = {
        tag: 'input',
        attrs: {
          type: 'text',
          ariaLabel: 'Class for column',
          value: _this.get('attrs.className'),
          placeholder: mi18n_min_default.a.get('class')
        },
        action: {
          input: function input(_ref2) {
            var value = _ref2.target.value;
            return _this.set('attrs.className', value);
          }
        },
        className: ''
      };
      editWindow.children = [classLabel, classInput];
      return editWindow;
    }
  }]);

  return Column;
}(components_component["a" /* default */]);


// CONCATENATED MODULE: ../src/js/components/columns/index.js
function columns_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var columns_DEFAULT_CONFIG = {
  actionButtons: {
    buttons: ['handle', 'edit', 'clone', 'remove'],
    disabled: []
  }
};
var columns_Columns = function (_ComponentData) {
  columns_inheritsLoose(Columns, _ComponentData);

  function Columns(columnData) {
    var _this;

    _this = _ComponentData.call(this, 'columns', columnData) || this;
    _this.config = {
      all: columns_DEFAULT_CONFIG
    };
    return _this;
  }

  var _proto = Columns.prototype;

  _proto.Component = function Component(data) {
    return new column_Column(data);
  };

  return Columns;
}(component_data_ComponentData);
var columns_columns = new columns_Columns();
/* harmony default export */ var components_columns = (columns_columns);
// EXTERNAL MODULE: ../src/js/components/fields/field.js + 3 modules
var field = __webpack_require__(40);

// CONCATENATED MODULE: ../src/js/components/fields/index.js
function fields_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function fields_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function fields_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var fields_DEFAULT_CONFIG = {
  actionButtons: {
    buttons: ['handle', 'edit', 'clone', 'remove'],
    disabled: []
  },
  panels: {
    disabled: [],
    attrs: {
      disabled: ['type'],
      hideDisabled: true,
      locked: []
    },
    order: ['attrs', 'options', 'conditions']
  },
  label: {
    disableHTML: false
  }
};
var fields_Fields = function (_ComponentData) {
  fields_inheritsLoose(Fields, _ComponentData);

  function Fields(fieldData) {
    var _this;

    _this = _ComponentData.call(this, 'fields', fieldData) || this;

    fields_defineProperty(fields_assertThisInitialized(_this), "get", function (path) {
      var found = path && Object(helpers["d" /* get */])(_this.data, path);

      if (!found) {
        var control = controls["a" /* default */].get(path);

        if (control) {
          found = _this.add(null, control.controlData);
        }
      }

      return found;
    });

    _this.config = {
      all: fields_DEFAULT_CONFIG
    };
    return _this;
  }

  var _proto = Fields.prototype;

  _proto.Component = function Component(data) {
    return new field["a" /* default */](data);
  };

  return Fields;
}(component_data_ComponentData);
var fields_fields = new fields_Fields();
/* harmony default export */ var components_fields = (fields_fields);
// CONCATENATED MODULE: ../src/js/components/externals.js
function externals_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var externals_Externals = function (_ComponentData) {
  externals_inheritsLoose(Externals, _ComponentData);

  function Externals(externalData) {
    return _ComponentData.call(this, 'externals', externalData) || this;
  }

  var _proto = Externals.prototype;

  _proto.Component = function Component(data) {
    return new components_component["a" /* default */]('external', data);
  };

  return Externals;
}(component_data_ComponentData);
var externals = new externals_Externals();
/* harmony default export */ var components_externals = (externals);
// CONCATENATED MODULE: ../src/js/components/index.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return components_Stages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return components_Rows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return components_Columns; });
/* unused harmony export Fields */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Controls; });
/* unused harmony export Externals */
/* unused harmony export Components */
function components_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function components_createClass(Constructor, protoProps, staticProps) { if (protoProps) components_defineProperties(Constructor.prototype, protoProps); if (staticProps) components_defineProperties(Constructor, staticProps); return Constructor; }

function components_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function components_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function components_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var components_Stages = components_stages;
var components_Rows = components_rows;
var components_Columns = components_columns;
var components_Fields = components_fields;
var Controls = controls["a" /* default */];
var components_Externals = components_externals;
var components_DEFAULT_DATA = {
  id: Object(utils["n" /* uuid */])()
};
var components_Components = function (_Data) {
  components_inheritsLoose(Components, _Data);

  function Components(_opts) {
    var _this;

    _this = _Data.call(this, 'components') || this;

    components_defineProperty(components_assertThisInitialized(_this), "sessionFormData", function () {
      if (_this.opts && _this.opts.sessionStorage) {
        return utils["l" /* sessionStorage */].get(constants["F" /* SESSION_FORMDATA_KEY */]);
      }
    });

    components_defineProperty(components_assertThisInitialized(_this), "load", function (formData, opts) {
      var _ref;

      if (opts === void 0) {
        opts = _this.opts || Object.create(null);
      }

      _this.empty();

      if (typeof formData === 'string') {
        formData = JSON.parse(formData);
      }

      _this.opts = opts;

      var _Object$assign = Object.assign({}, _this.sessionFormData(), formData),
          _Object$assign$stages = _Object$assign.stages,
          stages = _Object$assign$stages === void 0 ? (_ref = {}, _ref[Object(utils["n" /* uuid */])()] = {}, _ref) : _Object$assign$stages,
          rows = _Object$assign.rows,
          columns = _Object$assign.columns,
          fields = _Object$assign.fields,
          _Object$assign$id = _Object$assign.id,
          id = _Object$assign$id === void 0 ? Object(utils["n" /* uuid */])() : _Object$assign$id;

      _this.set('id', id);

      _this.add('stages', components_Stages.load(stages));

      _this.add('rows', components_Rows.load(rows));

      _this.add('columns', components_Columns.load(columns));

      _this.add('fields', components_Fields.load(fields));

      _this.add('externals', components_Externals.load(opts.external));

      Object.values(_this.get('stages')).forEach(function (stage) {
        return stage.loadChildren();
      });
      return _this.data;
    });

    _this.opts = _opts;
    _this.data = components_DEFAULT_DATA;
    _this.disableEvents = true;
    _this.stages = components_Stages;
    _this.rows = components_Rows;
    _this.columns = components_Columns;
    _this.fields = components_Fields;
    _this.controls = Controls;
    _this.externals = components_Externals;
    return _this;
  }

  var _proto = Components.prototype;

  _proto.flatList = function flatList(data, acculumator) {
    if (data === void 0) {
      data = this.data;
    }

    if (acculumator === void 0) {
      acculumator = Object.create(null);
    }

    return Object.entries(data).reduce(function (acc, _ref2) {
      var type = _ref2[0],
          components = _ref2[1];

      if (typeof components === 'object') {
        Object.entries(components).forEach(function (_ref3) {
          var id = _ref3[0],
              component = _ref3[1];
          acc[type + "." + id] = component;
        });
      }

      return acc;
    }, acculumator);
  };

  _proto.setAddress = function setAddress(address, value) {
    var _ref4 = Array.isArray(address) ? address : address.split('.'),
        type = _ref4[0],
        id = _ref4[1],
        path = _ref4.slice(2);

    var componentType = type.replace(/s?$/, 's');
    var component = this[componentType].get(id);

    if (component) {
      component.set(path, value);
    }

    return component;
  };

  _proto.getAddress = function getAddress(address) {
    if (!Object(utils["d" /* isAddress */])(address)) {
      return;
    }

    var _ref5 = Array.isArray(address) ? address : address.split('.'),
        type = _ref5[0],
        id = _ref5[1],
        path = _ref5.slice(2);

    var componentType = type.replace(/s?$/, 's');
    var component = this[componentType].get(id);
    return path.length ? component.get(path) : component;
  };

  _proto.getConditionMap = function getConditionMap(address) {
    if (Object(utils["d" /* isAddress */])(address)) {
      var splitAddress = address.split('.');
      return splitAddress.every(function (segment) {
        return Boolean(segment);
      }) && this[splitAddress[0]].conditionMap.get(splitAddress[1]);
    }
  };

  _proto.setConditionMap = function setConditionMap(address, component) {
    if (Object(utils["d" /* isAddress */])(address)) {
      var splitAddress = address.split('.');
      return splitAddress.every(function (segment) {
        return Boolean(segment);
      }) && this[splitAddress[0]].conditionMap.set(splitAddress[1], component);
    }
  };

  _proto.removeConditionMap = function removeConditionMap(address) {
    if (Object(utils["d" /* isAddress */])(address)) {
      var splitAddress = address.split('.');
      return splitAddress.every(function (segment) {
        return Boolean(segment);
      }) && this[splitAddress[0]].conditionMap.delete(splitAddress[1]);
    }
  };

  components_createClass(Components, [{
    key: "json",
    get: function get() {
      return window.JSON.stringify(this.formData);
    }
  }, {
    key: "formData",
    get: function get() {
      return {
        id: this.get('id'),
        stages: components_stages.getData(),
        rows: components_rows.getData(),
        columns: components_columns.getData(),
        fields: components_fields.getData()
      };
    }
  }, {
    key: "config",
    set: function set(config) {
      var stages = config.stages,
          rows = config.rows,
          columns = config.columns,
          fields = config.fields;
      components_Stages.config = stages;
      components_Rows.config = rows;
      components_Columns.config = columns;
      components_Fields.config = fields;
    }
  }]);

  return Components;
}(components_data["a" /* default */]);
var components = new components_Components();
/* harmony default export */ var js_components = __webpack_exports__["e"] = (components);

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }




var NO_TRANSITION_CLASS_NAME = 'no-transition';
var defaults = {
  debug: false,
  bubbles: true,
  formeoLoaded: function formeoLoaded(evt) {},
  onAdd: function onAdd() {},
  onUpdate: function onUpdate(evt) {
    return events.opts.debug && console.log(evt);
  },
  onUpdateStage: function onUpdateStage(evt) {
    return events.opts.debug && console.log(evt);
  },
  onUpdateRow: function onUpdateRow(evt) {
    return events.opts.debug && console.log(evt);
  },
  onUpdateColumn: function onUpdateColumn(evt) {
    return events.opts.debug && console.log(evt);
  },
  onUpdateField: function onUpdateField(evt) {
    return events.opts.debug && console.log(evt);
  },
  onRender: function onRender(evt) {
    return events.opts.debug && console.log(evt);
  },
  onSave: function onSave(evt) {},
  confirmClearAll: function confirmClearAll(evt) {
    if (window.confirm(evt.confirmationMessage)) {
      evt.clearAllAction(evt);
    }
  }
};

var defaultCustomEvent = function defaultCustomEvent(_ref, type) {
  if (type === void 0) {
    type = _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED */ "t"];
  }

  var src = _ref.src,
      evtData = _objectWithoutPropertiesLoose(_ref, ["src"]);

  var evt = new window.CustomEvent(type, {
    detail: evtData,
    bubbles: events.opts.debug || events.opts.bubbles
  });
  evt.data = (src || document).dispatchEvent(evt);
  return evt;
};

var events = {
  init: function init(options) {
    this.opts = Object.assign({}, defaults, options);
    return this;
  },
  formeoSaved: function formeoSaved(evt) {
    return defaultCustomEvent(evt, _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_SAVED */ "s"]);
  },
  formeoUpdated: function formeoUpdated(evt) {
    return defaultCustomEvent(evt, _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED */ "t"]);
  },
  formeoCleared: function formeoCleared(evt) {
    return defaultCustomEvent(evt, _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_CLEARED */ "p"]);
  },
  formeoOnRender: function formeoOnRender(evt) {
    return defaultCustomEvent(evt, _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_ON_RENDER */ "r"]);
  },
  formeoConditionUpdated: function formeoConditionUpdated(evt) {
    return defaultCustomEvent(evt, _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_CONDITION_UPDATED */ "q"]);
  }
};
var formeoUpdatedThrottled = lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default()(function () {
  events.opts.onUpdate({
    timeStamp: window.performance.now(),
    type: _constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED */ "t"],
    detail: _components__WEBPACK_IMPORTED_MODULE_2__[/* default */ "e"].formData
  });
}, _constants__WEBPACK_IMPORTED_MODULE_1__[/* ANIMATION_SPEED_FAST */ "b"], {
  leading: false
});
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED */ "t"], formeoUpdatedThrottled);
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED_STAGE */ "x"], function (evt) {
  var timeStamp = evt.timeStamp,
      type = evt.type,
      detail = evt.detail;
  events.opts.onUpdate({
    timeStamp: timeStamp,
    type: type,
    detail: detail
  });
});
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED_ROW */ "w"], function (evt) {
  var timeStamp = evt.timeStamp,
      type = evt.type,
      detail = evt.detail;
  events.opts.onUpdate({
    timeStamp: timeStamp,
    type: type,
    detail: detail
  });
});
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED_COLUMN */ "u"], function (evt) {
  var timeStamp = evt.timeStamp,
      type = evt.type,
      detail = evt.detail;
  events.opts.onUpdate({
    timeStamp: timeStamp,
    type: type,
    detail: detail
  });
});
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_UPDATED_FIELD */ "v"], function (evt) {
  var timeStamp = evt.timeStamp,
      type = evt.type,
      detail = evt.detail;
  events.opts.onUpdate({
    timeStamp: timeStamp,
    type: type,
    detail: detail
  });
});
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_ON_RENDER */ "r"], function (evt) {
  var timeStamp = evt.timeStamp,
      type = evt.type,
      detail = evt.detail;
  events.opts.onRender({
    timeStamp: timeStamp,
    type: type,
    detail: detail
  });
});
document.addEventListener('confirmClearAll', function (evt) {
  evt = {
    timeStamp: evt.timeStamp,
    type: evt.type,
    confirmationMessage: evt.detail.confirmationMessage,
    clearAllAction: evt.detail.clearAllAction,
    btnCoords: evt.detail.btnCoords
  };
  events.opts.confirmClearAll(evt);
});
document.addEventListener(_constants__WEBPACK_IMPORTED_MODULE_1__[/* EVENT_FORMEO_SAVED */ "s"], function (_ref2) {
  var timeStamp = _ref2.timeStamp,
      type = _ref2.type,
      formData = _ref2.detail.formData;
  var evt = {
    timeStamp: timeStamp,
    type: type,
    formData: formData
  };
  events.opts.onSave(evt);
});
document.addEventListener('formeoLoaded', function (evt) {
  events.opts.formeoLoaded(evt.detail.formeo);
});
var throttling;

function onResizeWindow() {
  throttling = throttling || window.requestAnimationFrame(function () {
    throttling = false;
    Object.values(_components__WEBPACK_IMPORTED_MODULE_2__[/* Columns */ "a"].data).forEach(function (column) {
      column.dom.classList.add(NO_TRANSITION_CLASS_NAME);
      _components__WEBPACK_IMPORTED_MODULE_2__[/* Controls */ "b"].dom.classList.add(NO_TRANSITION_CLASS_NAME);
      _components__WEBPACK_IMPORTED_MODULE_2__[/* Controls */ "b"].panels.nav.refresh();
      column.refreshFieldPanels();
      lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default()(function () {
        column.dom.classList.remove(NO_TRANSITION_CLASS_NAME);
        _components__WEBPACK_IMPORTED_MODULE_2__[/* Controls */ "b"].dom.classList.remove(NO_TRANSITION_CLASS_NAME);
      }, 1000, {
        leading: false
      });
    });
  });
}

window.addEventListener('resize', onResizeWindow);
/* harmony default export */ __webpack_exports__["a"] = (events);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var animate = {
  getStyle: function getStyle(elem, property) {
    if (property === void 0) {
      property = false;
    }

    var style;

    if (window.getComputedStyle) {
      style = window.getComputedStyle(elem, null);
    } else if (elem.currentStyle) {
      style = elem.currentStyle;
    }

    return property ? style[property] : style;
  },
  fadeOut: function fadeOut(elem, duration) {
    if (duration === void 0) {
      duration = 250;
    }

    var increment = 1 / (duration / 60);
    elem.style.opacity = 1;

    (function fade() {
      var val = Number(elem.style.opacity) - increment;

      if (val > 0) {
        elem.style.opacity = val;
        window.requestAnimationFrame(fade);
      } else {
        elem.remove();
      }
    })();
  },
  slideDown: function slideDown(elem, duration, cb) {
    if (duration === void 0) {
      duration = 250;
    }

    if (cb === void 0) {
      cb = false;
    }

    elem.style.display = 'block';
    var style = animate.getStyle(elem);
    var height = parseInt(style.height, 10);
    var increment = height / (duration / 60);
    elem.style.height = '0px';

    (function slideDown() {
      var curHeight = parseFloat(elem.style.height);
      var val = curHeight + increment;

      if (curHeight < height) {
        elem.style.height = val + 'px';
        window.requestAnimationFrame(slideDown);
      } else {
        elem.style.height = 'auto';

        if (cb) {
          cb(elem);
        }
      }
    })();
  },
  slideUp: function slideUp(elem, duration, cb) {
    if (duration === void 0) {
      duration = 250;
    }

    if (cb === void 0) {
      cb = false;
    }

    var style = animate.getStyle(elem);
    var height = parseInt(style.height);
    var overFlowBack = style.overflow;
    elem.style.overflow = 'hidden';
    elem.style.height = height + 'px';
    var defMinHeight = style.minHeight;
    elem.style.minHeight = 'auto';
    var increment = parseFloat(height / (duration / 60)).toFixed(2);

    (function slideUp() {
      var curHeight = parseInt(elem.style.height, 10);
      var val = curHeight - increment;

      if (val > 0) {
        elem.style.height = val + 'px';
        window.requestAnimationFrame(slideUp);
      } else {
        elem.style.overflow = overFlowBack;
        elem.style.display = 'none';
        elem.style.minHeight = defMinHeight;
        delete elem.style.height;

        if (cb) {
          cb(elem);
        }
      }
    })();
  },
  slideToggle: function slideToggle(elem, duration, open) {
    if (duration === void 0) {
      duration = 250;
    }

    if (open === void 0) {
      open = animate.getStyle(elem, 'display') === 'none';
    }

    if (open) {
      animate.slideDown(elem, duration);
    } else {
      animate.slideUp(elem, duration);
    }
  }
};
/* harmony default export */ __webpack_exports__["a"] = (animate);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var createCompounder = __webpack_require__(55),
    upperFirst = __webpack_require__(78);

/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + upperFirst(word);
});

module.exports = startCase;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(62);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return insertScript; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return insertStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return insertIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return loadPolyfills; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ajax; });
/* harmony import */ var lodash_noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90);
/* harmony import */ var lodash_noop__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_noop__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
var _this = undefined;




var loaded = {
  js: [],
  css: []
};
var insertScript = function insertScript(src) {
  return new Promise(function (resolve, reject) {
    if (loaded.js.includes(src)) {
      return resolve(src);
    }

    var script = _dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].create({
      tag: 'script',
      attrs: {
        type: 'text/javascript',
        async: true,
        src: "//" + _this.src
      },
      action: {
        load: function load() {
          loaded.js.push(src);
          resolve(src);
        },
        error: function error() {
          return reject(new Error(_this.src + " failed to load."));
        }
      }
    });
    var el = document.getElementsByTagName('script')[0];
    el.parentNode.insertBefore(script, el);
  });
};
var insertStyle = function insertStyle(srcs) {
  srcs = Array.isArray(srcs) ? srcs : [srcs];
  var promises = srcs.map(function (src) {
    return new Promise(function (resolve, reject) {
      if (loaded.css.includes(src)) {
        return resolve(src);
      }

      function onLoad() {
        this.removeEventListener('load', onLoad);
        this.rel = 'stylesheet';
        loaded.css.push(src);
        resolve(src);
      }

      var styleLink = _dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].create({
        tag: 'link',
        attrs: {
          rel: 'preload',
          href: src,
          as: 'style'
        },
        action: {
          load: onLoad,
          error: function error() {
            return reject(new Error(_this.src + " failed to load."));
          }
        }
      });
      document.head.appendChild(styleLink);
    });
  });
  return Promise.all(promises);
};
var insertIcons = function insertIcons(resp) {
  var spritePromise = typeof resp === 'string' ? Promise.resolve(resp) : resp.text();
  return spritePromise.then(function (iconSvgStr) {
    var id = 'formeo-sprite';
    var iconSpriteWrap = document.getElementById(id);

    if (!iconSpriteWrap) {
      iconSpriteWrap = _dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].create({
        id: id,
        children: iconSvgStr,
        attrs: {
          hidden: true,
          style: 'display: none;'
        }
      });
      document.body.insertBefore(iconSpriteWrap, document.body.childNodes[0]);
    }

    return iconSpriteWrap;
  });
};
var loadPolyfills = function loadPolyfills(polyfillConfig) {
  var polyfills = Array.isArray(polyfillConfig) ? _constants__WEBPACK_IMPORTED_MODULE_2__[/* POLYFILLS */ "D"].filter(function (_ref) {
    var name = _ref.name;
    return polyfillConfig.indexOf(name) !== -1;
  }) : _constants__WEBPACK_IMPORTED_MODULE_2__[/* POLYFILLS */ "D"];
  return Promise.all(polyfills.map(function (_ref2) {
    var src = _ref2.src;
    return insertScript(src);
  }));
};
var ajax = function ajax(file, callback, onError) {
  if (onError === void 0) {
    onError = lodash_noop__WEBPACK_IMPORTED_MODULE_0___default.a;
  }

  return new Promise(function (resolve, reject) {
    return fetch(file).then(function (data) {
      return resolve(callback ? callback(data) : data);
    }).catch(function (err) {
      return reject(onError(err));
    });
  });
};

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/sortablejs/modular/sortable.esm.js
var sortable_esm = __webpack_require__(14);

// EXTERNAL MODULE: ../node_modules/mi18n/dist/mi18n.min.js
var mi18n_min = __webpack_require__(2);
var mi18n_min_default = /*#__PURE__*/__webpack_require__.n(mi18n_min);

// EXTERNAL MODULE: ../node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__(59);
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);

// EXTERNAL MODULE: ../src/js/common/actions.js
var actions = __webpack_require__(19);

// EXTERNAL MODULE: ../src/js/common/helpers.js
var helpers = __webpack_require__(4);

// EXTERNAL MODULE: ../src/js/common/events.js
var common_events = __webpack_require__(6);

// EXTERNAL MODULE: ../src/js/common/dom.js
var dom = __webpack_require__(0);

// EXTERNAL MODULE: ../src/js/common/utils.js
var utils = __webpack_require__(3);

// EXTERNAL MODULE: ../src/js/components/panels.js
var panels = __webpack_require__(39);

// EXTERNAL MODULE: ../src/js/components/fields/field.js + 3 modules
var fields_field = __webpack_require__(40);

// EXTERNAL MODULE: ../src/js/common/loaders.js
var loaders = __webpack_require__(11);

// EXTERNAL MODULE: ../node_modules/lodash/identity.js
var identity = __webpack_require__(13);
var identity_default = /*#__PURE__*/__webpack_require__.n(identity);

// CONCATENATED MODULE: ../src/js/components/controls/control.js
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var LOADER_MAP = {
  js: loaders["c" /* insertScript */],
  css: loaders["d" /* insertStyle */]
};

var control_Control = function () {
  function Control(_ref) {
    if (_ref === void 0) {
      _ref = {};
    }

    var _ref2 = _ref,
        _ref2$events = _ref2.events,
        events = _ref2$events === void 0 ? {} : _ref2$events,
        _ref2$dependencies = _ref2.dependencies,
        dependencies = _ref2$dependencies === void 0 ? {} : _ref2$dependencies,
        restConfig = _objectWithoutPropertiesLoose(_ref2, ["events", "dependencies"]);

    _defineProperty(this, "parsedHtml", function (html) {
      var escapeElement = document.createElement('textarea');
      escapeElement.innerHTML = html;
      return escapeElement.textContent;
    });

    this.events = events;
    this.controlData = restConfig;
    this.depsLoaded = this.fetchDependencies(dependencies);
  }

  var _proto = Control.prototype;

  _proto.onRenderPreview = function onRenderPreview() {};

  _proto.fetchDependencies = function fetchDependencies(dependencies, cache) {
    if (cache === void 0) {
      cache = true;
    }

    var promises = Object.entries(dependencies).map(function (_ref3) {
      var type = _ref3[0],
          src = _ref3[1];
      return LOADER_MAP[type](src);
    });
    return Promise.all(promises);
  };

  _proto.on = function on(eventType) {
    var _this = this;

    var events = {
      prerender: identity_default.a,
      renderComponent: identity_default.a,
      render: function render(evt) {
        var onRender = function onRender() {
          if (_this.onRender) {
            _this.onRender(evt);
          }
        };

        _this.depsLoaded.then(function () {
          onRender(evt);
        });
      }
    };
    return eventType ? events[eventType] : events;
  };

  Control.i18n = function i18n(lookup, args) {
    var def = this.definition;
    var i18n = def.i18n || {};
    var locale = i18n.locale;
    i18n = i18n[locale] || i18n.default || i18n;
    var value = typeof i18n === 'object' ? i18n[lookup] : i18n;

    if (value) {
      return value;
    }

    var mapped = def.i18n;

    if (typeof mapped === 'object') {
      mapped = mapped[lookup];
    }

    return i18n.get(mapped, args);
  };

  return Control;
}();


// EXTERNAL MODULE: ../src/js/constants.js
var constants = __webpack_require__(1);

// EXTERNAL MODULE: ../src/js/components/index.js + 10 modules
var components = __webpack_require__(5);

// CONCATENATED MODULE: ../src/js/components/controls/layout/row.js
var rowControl = {
  config: {
    label: 'row',
    hideLabel: true
  },
  attrs: {
    className: ''
  },
  meta: {
    group: 'layout',
    icon: 'rows',
    id: 'layout-row'
  }
};
/* harmony default export */ var layout_row = (rowControl);
// CONCATENATED MODULE: ../src/js/components/controls/layout/column.js
var columnControl = {
  config: {
    label: 'column',
    hideLabel: true
  },
  attrs: {
    className: ''
  },
  meta: {
    group: 'layout',
    icon: 'columns',
    id: 'layout-column'
  }
};
/* harmony default export */ var column = (columnControl);
// CONCATENATED MODULE: ../src/js/components/controls/layout/index.js


/* harmony default export */ var layout = ([layout_row, column]);
// CONCATENATED MODULE: ../src/js/components/controls/form/input.hidden.js
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var input_hidden_HiddenControl = function (_Control) {
  _inheritsLoose(HiddenControl, _Control);

  function HiddenControl() {
    var hiddenInput = {
      tag: 'input',
      attrs: {
        type: 'hidden',
        value: ''
      },
      config: {
        label: mi18n_min_default.a.get('hidden'),
        hideLabel: true
      },
      meta: {
        group: 'common',
        icon: 'hidden',
        id: 'hidden'
      }
    };
    return _Control.call(this, hiddenInput) || this;
  }

  return HiddenControl;
}(control_Control);

/* harmony default export */ var input_hidden = (input_hidden_HiddenControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/input.number.js
function input_number_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var input_number_NumberControl = function (_Control) {
  input_number_inheritsLoose(NumberControl, _Control);

  function NumberControl() {
    var numberInput = {
      tag: 'input',
      attrs: {
        type: 'number',
        required: false,
        className: ''
      },
      config: {
        label: mi18n_min_default.a.get('number')
      },
      meta: {
        group: 'common',
        icon: 'hash',
        id: 'number'
      }
    };
    return _Control.call(this, numberInput) || this;
  }

  return NumberControl;
}(control_Control);

/* harmony default export */ var input_number = (input_number_NumberControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/textarea.js
function textarea_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var textarea_TextAreaControl = function (_Control) {
  textarea_inheritsLoose(TextAreaControl, _Control);

  function TextAreaControl() {
    var textAreaConfig = {
      tag: 'textarea',
      config: {
        label: mi18n_min_default.a.get('controls.form.textarea')
      },
      meta: {
        group: 'common',
        icon: 'textarea',
        id: 'textarea'
      },
      attrs: {
        required: false,
        className: ''
      }
    };
    return _Control.call(this, textAreaConfig) || this;
  }

  return TextAreaControl;
}(control_Control);

/* harmony default export */ var form_textarea = (textarea_TextAreaControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/input.text.js
function input_text_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var input_text_TextControl = function (_Control) {
  input_text_inheritsLoose(TextControl, _Control);

  function TextControl() {
    var textInput = {
      tag: 'input',
      attrs: {
        required: false,
        type: 'text',
        className: ''
      },
      config: {
        label: mi18n_min_default.a.get('controls.form.input.text')
      },
      meta: {
        group: 'common',
        icon: 'text-input',
        id: 'text-input'
      }
    };
    return _Control.call(this, textInput) || this;
  }

  return TextControl;
}(control_Control);

/* harmony default export */ var input_text = (input_text_TextControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/input.file.js
function input_file_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var input_file_FileControl = function (_Control) {
  input_file_inheritsLoose(FileControl, _Control);

  function FileControl() {
    var fileInput = {
      tag: 'input',
      attrs: {
        type: 'file',
        required: false
      },
      config: {
        label: mi18n_min_default.a.get('fileUpload')
      },
      meta: {
        group: 'common',
        icon: 'upload',
        id: 'upload'
      }
    };
    return _Control.call(this, fileInput) || this;
  }

  return FileControl;
}(control_Control);

/* harmony default export */ var input_file = (input_file_FileControl);
// EXTERNAL MODULE: ../node_modules/lodash/startCase.js
var startCase = __webpack_require__(8);
var startCase_default = /*#__PURE__*/__webpack_require__.n(startCase);

// CONCATENATED MODULE: ../src/js/components/controls/form/shared.js


var shared_generateOptionConfig = function generateOptionConfig(type, count) {
  if (count === void 0) {
    count = 3;
  }

  return Array.from({
    length: count
  }, function (v, k) {
    return k + 1;
  }).map(function (i) {
    var _ref;

    var selectedKey = type === 'checkbox' ? 'checked' : 'selected';
    return _ref = {
      label: mi18n_min_default.a.get('labelCount', {
        label: startCase_default()(type),
        count: i
      }),
      value: type + "-" + i
    }, _ref[selectedKey] = !i, _ref;
  });
};
// CONCATENATED MODULE: ../src/js/components/controls/form/select.js
function select_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var select_SelectControl = function (_Control) {
  select_inheritsLoose(SelectControl, _Control);

  function SelectControl() {
    var selectConfig = {
      tag: 'select',
      config: {
        label: mi18n_min_default.a.get('controls.form.select')
      },
      attrs: {
        required: false,
        className: ''
      },
      meta: {
        group: 'common',
        icon: 'select',
        id: 'select'
      },
      options: shared_generateOptionConfig('option')
    };
    return _Control.call(this, selectConfig) || this;
  }

  return SelectControl;
}(control_Control);

/* harmony default export */ var form_select = (select_SelectControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/checkbox-group.js
function checkbox_group_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var checkbox_group_CheckboxGroupControl = function (_Control) {
  checkbox_group_inheritsLoose(CheckboxGroupControl, _Control);

  function CheckboxGroupControl() {
    var checkboxGroup = {
      tag: 'input',
      attrs: {
        type: 'checkbox',
        required: false
      },
      config: {
        label: mi18n_min_default.a.get('controls.form.checkbox-group'),
        disabledAttrs: ['type']
      },
      meta: {
        group: 'common',
        icon: 'checkbox',
        id: 'checkbox'
      },
      options: shared_generateOptionConfig('checkbox', 1)
    };
    return _Control.call(this, checkboxGroup) || this;
  }

  return CheckboxGroupControl;
}(control_Control);

/* harmony default export */ var checkbox_group = (checkbox_group_CheckboxGroupControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/radio-group.js
function radio_group_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var radio_group_RadioGroupControl = function (_Control) {
  radio_group_inheritsLoose(RadioGroupControl, _Control);

  function RadioGroupControl() {
    var radioGroup = {
      tag: 'input',
      attrs: {
        type: 'radio',
        required: false
      },
      config: {
        label: mi18n_min_default.a.get('controls.form.radio-group'),
        disabledAttrs: ['type']
      },
      meta: {
        group: 'common',
        icon: 'radio-group',
        id: 'radio'
      },
      options: shared_generateOptionConfig('radio')
    };
    return _Control.call(this, radioGroup) || this;
  }

  return RadioGroupControl;
}(control_Control);

/* harmony default export */ var radio_group = (radio_group_RadioGroupControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/button.js
function button_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var button_ButtonControl = function (_Control) {
  button_inheritsLoose(ButtonControl, _Control);

  function ButtonControl() {
    var buttonConfig = {
      tag: 'button',
      attrs: {
        className: [{
          label: 'grouped',
          value: 'f-btn-group'
        }, {
          label: 'ungrouped',
          value: 'f-field-group'
        }]
      },
      config: {
        label: mi18n_min_default.a.get('controls.form.button'),
        hideLabel: true
      },
      meta: {
        group: 'common',
        icon: 'button',
        id: 'button'
      },
      options: [{
        label: mi18n_min_default.a.get('button'),
        type: ['button', 'submit', 'reset'].map(function (buttonType, index) {
          return {
            label: buttonType,
            type: buttonType
          };
        }),
        className: [{
          label: 'default',
          value: '',
          selected: true
        }, {
          label: 'primary',
          value: 'primary'
        }, {
          label: 'danger',
          value: 'error'
        }, {
          label: 'success',
          value: 'success'
        }, {
          label: 'warning',
          value: 'warning'
        }]
      }]
    };
    return _Control.call(this, buttonConfig) || this;
  }

  return ButtonControl;
}(control_Control);

/* harmony default export */ var form_button = (button_ButtonControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/input.date.js
function input_date_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var input_date_DateControl = function (_Control) {
  input_date_inheritsLoose(DateControl, _Control);

  function DateControl() {
    var dateInput = {
      tag: 'input',
      attrs: {
        type: 'date',
        required: false,
        className: ''
      },
      config: {
        label: mi18n_min_default.a.get('controls.form.input.date')
      },
      meta: {
        group: 'common',
        icon: 'calendar',
        id: 'date-input'
      }
    };
    return _Control.call(this, dateInput) || this;
  }

  return DateControl;
}(control_Control);

/* harmony default export */ var input_date = (input_date_DateControl);
// CONCATENATED MODULE: ../src/js/components/controls/form/index.js










/* harmony default export */ var controls_form = ([form_button, input_date, input_hidden, input_number, form_textarea, input_text, input_file, form_select, checkbox_group, radio_group]);
// CONCATENATED MODULE: ../src/js/components/controls/html/header.js
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function header_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var headerTags = Array.from(Array(5).keys()).slice(1).map(function (key) {
  return "h" + key;
});
var headerKey = 'controls.html.header';

var header_HeaderControl = function (_Control) {
  header_inheritsLoose(HeaderControl, _Control);

  function HeaderControl() {
    var header = {
      tag: headerTags[0],
      attrs: {
        tag: headerTags.map(function (tag, index) {
          return {
            label: tag.toUpperCase(),
            value: tag,
            selected: !index
          };
        }),
        className: ''
      },
      config: {
        label: mi18n_min_default.a.get(headerKey),
        hideLabel: true,
        editableContent: true
      },
      meta: {
        group: 'html',
        icon: 'header',
        id: 'html.header'
      },
      content: mi18n_min_default.a.get(headerKey)
    };
    return _Control.call(this, header) || this;
  }

  _createClass(HeaderControl, [{
    key: "content",
    get: function get() {
      return _Control.prototype.i18n.call(this, headerKey);
    }
  }], [{
    key: "definition",
    get: function get() {
      return {
        i18n: {
          header: 'Header222'
        }
      };
    }
  }]);

  return HeaderControl;
}(control_Control);

/* harmony default export */ var html_header = (header_HeaderControl);
// CONCATENATED MODULE: ../src/js/components/controls/html/paragraph.js
function paragraph_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var paragraph_ParagraphControl = function (_Control) {
  paragraph_inheritsLoose(ParagraphControl, _Control);

  function ParagraphControl() {
    var paragraphConfig = {
      tag: 'p',
      attrs: {
        className: ''
      },
      config: {
        label: mi18n_min_default.a.get('controls.html.paragraph'),
        hideLabel: true,
        editableContent: true
      },
      meta: {
        group: 'html',
        icon: 'paragraph',
        id: 'paragraph'
      },
      content: 'Leverage agile frameworks to provide a robust synopsis for high level overviews. Iterative approaches to corporate strategy foster collaborative thinking to further the overall value proposition. Organically grow the holistic world view of disruptive innovation via workplace diversity and empowerment.'
    };
    return _Control.call(this, paragraphConfig) || this;
  }

  return ParagraphControl;
}(control_Control);

/* harmony default export */ var paragraph = (paragraph_ParagraphControl);
// CONCATENATED MODULE: ../src/js/components/controls/html/hr.js
function hr_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var hr_HRControl = function (_Control) {
  hr_inheritsLoose(HRControl, _Control);

  function HRControl() {
    var hrConfig = {
      tag: 'hr',
      config: {
        label: mi18n_min_default.a.get('controls.html.divider'),
        hideLabel: true
      },
      meta: {
        group: 'html',
        icon: 'divider',
        id: 'divider'
      }
    };
    return _Control.call(this, hrConfig) || this;
  }

  return HRControl;
}(control_Control);

/* harmony default export */ var hr = (hr_HRControl);
// CONCATENATED MODULE: ../src/js/components/controls/html/index.js



/* harmony default export */ var html = ([html_header, paragraph, hr]);
// CONCATENATED MODULE: ../src/js/components/controls/options.js
var defaultOptions = Object.freeze({
  sortable: true,
  elementOrder: {},
  groupOrder: [],
  elementCustomizations: {},
  groups: [{
    id: 'layout',
    label: 'controls.groups.layout',
    elementOrder: ['row', 'column']
  }, {
    id: 'common',
    label: 'controls.groups.form',
    elementOrder: ['button', 'checkbox']
  }, {
    id: 'html',
    label: 'controls.groups.html',
    elementOrder: ['header', 'block-text']
  }],
  disable: {
    groups: [],
    elements: [],
    formActions: []
  },
  elements: [],
  container: null,
  panels: {
    displayType: 'slider'
  }
});
/* harmony default export */ var controls_options = (defaultOptions);
// CONCATENATED MODULE: ../src/js/components/controls/index.js
/* unused harmony export Controls */
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { controls_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function controls_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function controls_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















var defaultElements = [].concat(controls_form, html, layout);
var controls_Controls = function () {
  function Controls() {
    var _this = this;

    controls_defineProperty(this, "applyControlEvents", function (_ref) {
      var control = _ref.clone;
      var button = control.querySelector('button');
      Object.keys(_this.controlEvents).map(function (action) {
        return button.addEventListener(action, _this.controlEvents[action]);
      });
    });

    controls_defineProperty(this, "groupLabel", function (key) {
      return mi18n_min_default.a.get(key) || key || '';
    });

    controls_defineProperty(this, "addElement", function (id) {
      var controlData = Object(helpers["d" /* get */])(_this.get(id), 'controlData');
      var _controlData$meta = controlData.meta,
          group = _controlData$meta.group,
          metaId = _controlData$meta.id;
      var layoutTypes = {
        row: function row() {
          return components["d" /* Stages */].active.addChild();
        },
        column: function column() {
          return layoutTypes.row().addChild();
        },
        field: function field(controlData) {
          return layoutTypes.column().addChild(controlData);
        }
      };
      return group !== 'layout' ? layoutTypes.field(controlData) : layoutTypes[metaId.replace('layout-', '')]();
    });

    controls_defineProperty(this, "applyOptions", function (controlOptions) {
      if (controlOptions === void 0) {
        controlOptions = {};
      }

      var _merge = Object(utils["h" /* merge */])(controls_options, controlOptions),
          container = _merge.container,
          elements = _merge.elements,
          groupOrder = _merge.groupOrder,
          options = controls_objectWithoutPropertiesLoose(_merge, ["container", "elements", "groupOrder"]);

      _this.container = container;
      _this.groupOrder = Object(utils["m" /* unique */])(groupOrder.concat(['common', 'html', 'layout']));
      _this.elements = elements.concat(defaultElements);
      _this.options = options;
    });

    this.data = new Map();
    this.controlEvents = {
      focus: function focus(_ref2) {
        var target = _ref2.target;
        var group = target.closest("." + constants["o" /* CONTROL_GROUP_CLASSNAME */]);
        return group && _this.panels.nav.refresh(Object(helpers["f" /* indexOfNode */])(group));
      },
      click: function click(_ref3) {
        var target = _ref3.target;
        return _this.addElement(target.parentElement.id);
      }
    };
  }

  var _proto = Controls.prototype;

  _proto.init = function init(controlOptions, sticky) {
    if (sticky === void 0) {
      sticky = false;
    }

    this.applyOptions(controlOptions);
    this.registerControls();
    this.buildDOM(sticky);
    return this;
  };

  _proto.registerControls = function registerControls() {
    var _this2 = this;

    this.controls = this.elements.map(function (Element) {
      var isControl = typeof Element === 'function';
      var control = isControl ? new Element() : new control_Control(Element);
      var _control$controlData = control.controlData,
          meta = _control$controlData.meta,
          config = _control$controlData.config;
      var controlLabel = isControl ? config.label : mi18n_min_default.a.get(config.label) || config.label;

      var _this2$add = _this2.add(control),
          controlId = _this2$add.id;

      var button = {
        tag: 'button',
        attrs: {
          type: 'button'
        },
        content: [{
          tag: 'span',
          className: 'control-icon',
          children: dom["a" /* default */].icon(meta.icon)
        }, controlLabel],
        action: _this2.controlEvents
      };
      control.dom = dom["a" /* default */].create({
        tag: 'li',
        id: controlId,
        className: ['field-control', meta.group + "-control", meta.id + "-control"],
        content: button,
        meta: meta
      });
      return control.dom;
    });
    return this.controls;
  };

  _proto.groupElements = function groupElements() {
    var _this3 = this;

    var groups = this.options.groups.slice();
    var elements = this.controls.slice();
    var allGroups = [];
    var usedElementIds = [];
    groups = Object(helpers["j" /* orderObjectsBy */])(groups, this.groupOrder, 'id');
    groups = groups.filter(function (group) {
      return Object(utils["g" /* match */])(group.id, _this3.options.disable.groups);
    });
    allGroups = groups.map(function (group) {
      var groupConfig = {
        tag: 'ul',
        attrs: {
          className: constants["o" /* CONTROL_GROUP_CLASSNAME */],
          id: group.id + "-" + constants["o" /* CONTROL_GROUP_CLASSNAME */]
        },
        config: {
          label: _this3.groupLabel(group.label)
        }
      };

      if (_this3.options.elementOrder[group.id]) {
        var userOrder = _this3.options.elementOrder[group.id];
        var newOrder = Object(utils["m" /* unique */])(userOrder.concat(group.elementOrder));
        group.elementOrder = newOrder;
      }

      elements = Object(helpers["j" /* orderObjectsBy */])(elements, group.elementOrder, 'meta.id');
      groupConfig.content = elements.filter(function (control) {
        var _this3$get = _this3.get(control.id),
            field = _this3$get.controlData;

        var fieldId = field.meta.id || '';
        var filters = [Object(utils["g" /* match */])(fieldId, _this3.options.disable.elements), field.meta.group === group.id, !usedElementIds.includes(field.meta.id)];
        var shouldFilter = true;
        shouldFilter = filters.every(function (val) {
          return val === true;
        });

        if (shouldFilter) {
          usedElementIds.push(fieldId);
        }

        return shouldFilter;
      });
      return groupConfig;
    });
    return allGroups;
  };

  _proto.add = function add(control) {
    if (control === void 0) {
      control = Object.create(null);
    }

    var _control = control,
        id = _control.id,
        config = controls_objectWithoutPropertiesLoose(_control, ["id"]);

    var controlId = id || Object(utils["n" /* uuid */])();
    var controlConfig = cloneDeep_default()(config);
    var customConfig = this.options.elementCustomizations[config.controlData.meta.id];

    if (customConfig) {
      controlConfig.controlData = Object(utils["h" /* merge */])(controlConfig.controlData, customConfig);
    }

    this.data.set(controlId, controlConfig);
    return _objectSpread({
      id: controlId
    }, controlConfig);
  };

  _proto.get = function get(controlId) {
    return cloneDeep_default()(this.data.get(controlId));
  };

  _proto.formActions = function formActions() {
    var _this4 = this;

    if (this.options.disable.formActions === true) {
      return null;
    }

    var clearBtn = _objectSpread({}, dom["a" /* default */].btnTemplate({
      content: [dom["a" /* default */].icon('bin'), mi18n_min_default.a.get('clear')],
      title: mi18n_min_default.a.get('clearAll')
    }), {
      className: ['clear-form'],
      action: {
        click: function click(evt) {
          if (components["c" /* Rows */].size) {
            common_events["a" /* default */].confirmClearAll = new window.CustomEvent('confirmClearAll', {
              detail: {
                confirmationMessage: mi18n_min_default.a.get('confirmClearAll'),
                clearAllAction: function clearAllAction() {
                  components["d" /* Stages */].clearAll().then(function () {
                    var evtData = {
                      src: evt.target
                    };
                    common_events["a" /* default */].formeoCleared(evtData);
                  });
                },
                btnCoords: dom["a" /* default */].coords(evt.target)
              }
            });
            document.dispatchEvent(common_events["a" /* default */].confirmClearAll);
          } else {
            window.alert(mi18n_min_default.a.get('cannotClearFields'));
          }
        }
      }
    });

    var saveBtn = _objectSpread({}, dom["a" /* default */].btnTemplate({
      content: [dom["a" /* default */].icon('floppy-disk'), mi18n_min_default.a.get('save')],
      title: mi18n_min_default.a.get('save')
    }), {
      className: ['save-form'],
      action: {
        click: function click(_ref4) {
          var target = _ref4.target;
          var formData = components["e" /* default */].formData;
          var saveEvt = {
            action: function action() {},
            coords: dom["a" /* default */].coords(target),
            message: '',
            button: target
          };
          actions["a" /* default */].click.btn(saveEvt);
          return actions["a" /* default */].save.form(formData);
        }
      }
    });

    var formActions = {
      className: 'form-actions f-btn-group',
      content: Object.entries({
        clearBtn: clearBtn,
        saveBtn: saveBtn
      }).reduce(function (acc, _ref5) {
        var key = _ref5[0],
            value = _ref5[1];

        if (!_this4.options.disable.formActions.includes(key)) {
          acc.push(value);
        }

        return acc;
      }, [])
    };
    return formActions;
  };

  _proto.buildDOM = function buildDOM(sticky) {
    var _this5 = this;

    var groupedFields = this.groupElements();
    var formActions = this.formActions();
    var displayType = this.options.panels.displayType;
    this.panels = new panels["a" /* default */]({
      panels: groupedFields,
      type: 'controls',
      displayType: displayType
    });
    var groupsWrapClasses = ['control-groups', 'formeo-panels-wrap', "panel-count-" + groupedFields.length];
    var groupsWrap = dom["a" /* default */].create({
      className: groupsWrapClasses,
      content: [this.panels.panelNav, this.panels.panelsWrap]
    });
    var controlClass = 'formeo-controls';

    if (sticky) {
      controlClass += ' formeo-sticky';
    }

    var element = dom["a" /* default */].create({
      className: controlClass,
      content: [groupsWrap, formActions]
    });
    var groups = element.getElementsByClassName('control-group');
    this.dom = element;
    this.groups = groups;
    var firstGroup = groups[0];
    this.currentGroup = firstGroup;
    this.actions = {
      filter: function filter(term) {
        var filtering = term !== '';
        var fields = _this5.controls;
        var filteredTerm = groupsWrap.querySelector('.filtered-term');
        dom["a" /* default */].toggleElementsByStr(fields, term);

        if (filtering) {
          var filteredStr = mi18n_min_default.a.get('controls.filteringTerm', term);
          element.classList.add('filtered');

          if (filteredTerm) {
            filteredTerm.textContent = filteredStr;
          } else {
            filteredTerm = dom["a" /* default */].create({
              tag: 'h5',
              className: 'filtered-term',
              content: filteredStr
            });
            groupsWrap.insertBefore(filteredTerm, groupsWrap.firstChild);
          }
        } else if (filteredTerm) {
          element.classList.remove('filtered');
          filteredTerm.remove();
        }
      },
      addElement: this.addElement,
      addGroup: function addGroup(group) {
        return console.log(group);
      }
    };

    var _loop = function _loop(i) {
      var storeID = "formeo-controls-" + groups[i];

      if (!_this5.options.sortable) {
        window.localStorage.removeItem(storeID);
      }

      sortable_esm["a" /* default */].create(groups[i], {
        animation: 150,
        forceFallback: true,
        fallbackClass: 'control-moving',
        fallbackOnBody: true,
        group: {
          name: 'controls',
          pull: 'clone',
          put: false
        },
        onRemove: _this5.applyControlEvents,
        onStart: function onStart(_ref6) {
          var item = _ref6.item;

          var _this5$get = _this5.get(item.id),
              controlData = _this5$get.controlData;

          if (_this5.options.ghostPreview) {
            item.innerHTML = '';
            item.appendChild(new fields_field["a" /* default */](controlData).preview);
          }
        },
        sort: _this5.options.sortable,
        store: {
          get: function get() {
            var order = window.localStorage.getItem(storeID);
            return order ? order.split('|') : [];
          },
          set: function set(sortable) {
            var order = sortable.toArray();
            window.localStorage.setItem(storeID, order.join('|'));
          }
        }
      });
    };

    for (var i = groups.length - 1; i >= 0; i--) {
      _loop(i);
    }

    return element;
  };

  return Controls;
}();
/* harmony default export */ var controls = __webpack_exports__["a"] = (new controls_Controls());

/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MultiDrag */
/* unused harmony export Sortable */
/* unused harmony export Swap */
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var version = "1.10.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !!
    /*@__PURE__*/
    navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    if (lastChild(sortable)) return;
    var rect = getRect(sortable),
        threshold = sortable[expando].options.emptyInsertThreshold,
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (threshold && insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // assign target only if condition is true


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (sortable.options.supportPointer) {
      on(document, 'pointerup', this._deselectMultiDrag);
    } else {
      on(document, 'mouseup', this._deselectMultiDrag);
      on(document, 'touchend', this._deselectMultiDrag);
    }

    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      var sortable = _ref5.sortable,
          cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvt: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
                currentIndex = index(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ __webpack_exports__["a"] = (Sortable);



/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Component; });
/* harmony import */ var lodash_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var lodash_identity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_identity__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _common_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);
/* harmony import */ var _common_animation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);
/* harmony import */ var _controls__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var Component = function (_Data) {
  _inheritsLoose(Component, _Data);

  function Component(_name, data, render) {
    var _this2;

    if (data === void 0) {
      data = {};
    }

    _this2 = _Data.call(this, _name, Object.assign({}, data, {
      id: data.id || Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* uuid */ "n"])()
    })) || this;

    _defineProperty(_assertThisInitialized(_this2), "mutationHandler", function (mutations) {
      return mutations.map(function (mutation) {});
    });

    _defineProperty(_assertThisInitialized(_this2), "remove", function (path) {
      if (path) {
        var delPath = path.split('.');
        var delItem = delPath.pop();

        var _parent = _this2.get(delPath);

        if (Array.isArray(_parent)) {
          if (Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* isInt */ "h"])(delItem)) {
            _parent.splice(Number(delItem), 1);
          } else {
            _this2.set(delPath, _parent.filter(function (item) {
              return item !== delItem;
            }));
          }
        } else {
          delete _parent[delItem];
        }

        return _parent;
      }

      if (_this2.name === 'stage') {
        return null;
      }

      var parent = _this2.parent;
      var children = _this2.children;
      Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* forEach */ "c"])(children, function (child) {
        return child.remove();
      });

      _this2.dom.parentElement.removeChild(_this2.dom);

      Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* remove */ "k"])(_index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"].getAddress(parent.name + "s." + parent.id + ".children"), _this2.id);

      if (!parent.children.length) {
        parent.emptyClass();
      }

      if (parent.name === 'row') {
        parent.autoColumnWidths();
      }

      return _index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"][_this2.name + "s"].delete(_this2.id);
    });

    _defineProperty(_assertThisInitialized(_this2), "emptyClass", function () {
      return _this2.dom.classList.toggle('empty', !_this2.children.length);
    });

    _defineProperty(_assertThisInitialized(_this2), "removeClasses", function (className) {
      var removeClass = {
        string: function string() {
          return _this2.dom.classList.remove(className);
        },
        array: function array() {
          return className.map(function (name) {
            return _this2.dom.classList.remove(name);
          });
        }
      };
      removeClass.object = removeClass.string;
      return removeClass[_common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].childType(className)](_this2.dom);
    });

    _defineProperty(_assertThisInitialized(_this2), "loadChildren", function (children) {
      if (children === void 0) {
        children = _this2.data.children;
      }

      return children.map(function (rowId) {
        return _this2.addChild({
          id: rowId
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this2), "saveChildOrder", function () {
      if (_this2.render) {
        return;
      }

      var newChildOrder = _this2.children.map(function (_ref) {
        var id = _ref.id;
        return id;
      });

      _this2.set('children', newChildOrder);

      return newChildOrder;
    });

    _defineProperty(_assertThisInitialized(_this2), "onSort", function () {
      return _this2.saveChildOrder();
    });

    _defineProperty(_assertThisInitialized(_this2), "onEnd", function (_ref2) {
      var to = _ref2.to.parentElement,
          from = _ref2.from.parentElement;
      to && to.classList.remove("hovering-" + Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* componentType */ "c"])(to));
      from && from.classList.remove("hovering-" + Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* componentType */ "c"])(from));
    });

    _defineProperty(_assertThisInitialized(_this2), "runConditions", function () {
      var conditionsList = _this2.get('conditions');

      if (!conditionsList || !conditionsList.length) {
        return null;
      }

      var processedConditions = conditionsList.map(function (conditions) {
        var ifCondition = _this2.processConditions(conditions.if);

        var thenResult = _this2.processResults(conditions.then);

        return ifCondition.map(function (conditions) {
          return _this2.evaluateConditions(conditions) && _this2.execResults(thenResult);
        });
      });
      return processedConditions;
    });

    _defineProperty(_assertThisInitialized(_this2), "value", function (path, val) {
      var splitPath = path.split('.');

      var component = _this2.getComponent(path);

      var property = component && splitPath.slice(2, splitPath.length).join('.');

      if ([!component, !property, !_constants__WEBPACK_IMPORTED_MODULE_4__[/* FIELD_PROPERTY_MAP */ "A"][property]].some(Boolean)) {
        return path;
      }

      return val ? component.set(_constants__WEBPACK_IMPORTED_MODULE_4__[/* FIELD_PROPERTY_MAP */ "A"][property], val) : component.get(_constants__WEBPACK_IMPORTED_MODULE_4__[/* FIELD_PROPERTY_MAP */ "A"][property]);
    });

    _defineProperty(_assertThisInitialized(_this2), "getResult", function (operator) {
      var operatorMap = {
        '=': function _(target, propertyPath, value) {
          return target.set(propertyPath, value);
        }
      };
      return operatorMap[operator];
    });

    _defineProperty(_assertThisInitialized(_this2), "processResults", function (results) {
      return results.map(function (_ref3) {
        var operator = _ref3.operator,
            target = _ref3.target,
            value = _ref3.value;

        var targetComponent = _this2.getComponent(target);

        var propertyPath = targetComponent && target.split('.').slice(2, target.length).join('.');
        var processedResult = {
          target: targetComponent,
          propertyPath: propertyPath,
          action: _this2.getResult(operator),
          value: _this2.value(value)
        };
        return processedResult;
      });
    });

    _defineProperty(_assertThisInitialized(_this2), "execResults", function (results) {
      var promises = results.map(function (result) {
        return _this2.execResult(result);
      });
      return Promise.all(promises);
    });

    _defineProperty(_assertThisInitialized(_this2), "execResult", function (_ref4) {
      var target = _ref4.target,
          action = _ref4.action,
          value = _ref4.value,
          propertyPath = _ref4.propertyPath;
      return new Promise(function (resolve, reject) {
        try {
          return resolve(action(target, value));
        } catch (err) {
          return reject(err);
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this2), "cloneData", function () {
      var clonedData = _objectSpread({}, Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* clone */ "b"])(_this2.data), {
        id: Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* uuid */ "n"])()
      });

      if (_this2.name !== 'field') {
        clonedData.children = [];
      }

      return clonedData;
    });

    _defineProperty(_assertThisInitialized(_this2), "clone", function (parent) {
      if (parent === void 0) {
        parent = _this2.parent;
      }

      var newClone = parent.addChild(_this2.cloneData(), _this2.index + 1);

      if (_this2.name !== 'field') {
        _this2.cloneChildren(newClone);
      }

      if (_this2.name === 'column') {
        parent.autoColumnWidths();
      }

      return newClone;
    });

    _defineProperty(_assertThisInitialized(_this2), "cloneChildren", function (toParent) {
      _this2.children.forEach(function (child) {
        return child && child.clone(toParent);
      });
    });

    _defineProperty(_assertThisInitialized(_this2), "createChildWrap", function (children) {
      return _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].create({
        tag: 'ul',
        attrs: {
          className: 'children'
        },
        children: children
      });
    });

    _this2.id = _this2.data.id;
    _this2.name = _name;
    _this2.config = _index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"][_this2.name + "s"].config;
    Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* merge */ "h"])(_this2.config, data.config);
    _this2.dataPath = _this2.name + "s." + _this2.id + ".";
    _this2.observer = new MutationObserver(_this2.mutationHandler);
    _this2.render = render;
    return _this2;
  }

  var _proto = Component.prototype;

  _proto.observe = function observe(container) {
    this.observer.disconnect();
    this.observer.observe(container, {
      childList: true
    });
  };

  _proto.empty = function empty() {
    var removed = this.children.map(function (child) {
      return child.remove();
    });
    this.data.children = this.data.children.filter(function (childId) {
      return removed.indexOf(childId) === -1;
    });
    this.dom.classList.add('empty');
    return removed;
  };

  _proto.getActionButtons = function getActionButtons() {
    var _this3 = this;

    var expandSize = '97px';
    var hoverClassname = "hovering-" + this.name;
    return {
      className: this.name + "-actions group-actions",
      action: {
        onRender: function onRender(elem) {
          return expandSize = elem.getElementsByTagName('button').length * 24 + 1 + "px";
        },
        mouseenter: function mouseenter(_ref5) {
          var target = _ref5.target;

          _this3.dom.classList.add(hoverClassname);

          target.style[_this3.name === 'row' ? 'height' : 'width'] = expandSize;
        },
        mouseleave: function mouseleave(_ref6) {
          var target = _ref6.target;

          _this3.dom.classList.remove(hoverClassname);

          target.removeAttribute('style');
        }
      },
      children: {
        className: 'action-btn-wrap',
        children: this.buttons
      }
    };
  };

  _proto.toggleEdit = function toggleEdit(open) {
    if (open === void 0) {
      open = !this.isEditing;
    }

    this.isEditing = open;
    var element = this.dom;
    var editClass = "editing-" + this.name;
    var editWindow = this.dom.querySelector("." + this.name + "-edit");
    _common_animation__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].slideToggle(editWindow, _constants__WEBPACK_IMPORTED_MODULE_4__[/* ANIMATION_SPEED_BASE */ "a"], open);

    if (this.name === 'field') {
      _common_animation__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].slideToggle(this.preview, _constants__WEBPACK_IMPORTED_MODULE_4__[/* ANIMATION_SPEED_BASE */ "a"], !open);
      element.parentElement.classList.toggle("column-" + editClass, open);
    }

    element.classList.toggle(editClass, open);
  };

  _proto.addChild = function addChild(childData, index) {
    if (childData === void 0) {
      childData = {};
    }

    if (index === void 0) {
      index = this.domChildren.length;
    }

    if (typeof childData !== 'object') {
      childData = {
        id: childData
      };
    }

    var childWrap = this.dom.querySelector('.children');
    var _childData = childData,
        _childData$id = _childData.id,
        childId = _childData$id === void 0 ? Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* uuid */ "n"])() : _childData$id;
    var childGroup = _constants__WEBPACK_IMPORTED_MODULE_4__[/* CHILD_TYPE_MAP */ "f"].get(this.name);

    if (!childGroup) {
      return null;
    }

    var childComponentType = childGroup + "s";
    var child = _index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"].getAddress(childComponentType + "." + childId) || _index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"][childComponentType].add(childId, childData);
    childWrap.insertBefore(child.dom, childWrap.children[index]);
    var grandChildren = child.get('children');

    if (grandChildren && grandChildren.length) {
      child.loadChildren(grandChildren);
    }

    this.removeClasses('empty');
    this.saveChildOrder();
    return child;
  };

  _proto.onAdd = function onAdd(_ref7) {
    var from = _ref7.from,
        to = _ref7.to,
        item = _ref7.item,
        newIndex = _ref7.newIndex;

    var _this = this;

    if (!from.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__[/* CONTROL_GROUP_CLASSNAME */ "o"])) {
      from = from.parentElement;
    }

    var fromType = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* componentType */ "c"])(from);
    var toType = Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* componentType */ "c"])(to.parentElement);

    var defaultOnAdd = function defaultOnAdd() {
      _this.saveChildOrder();

      _this.removeClasses('empty');
    };

    var depthMap = new Map([[-2, function () {
      var newChild = _this.addChild({}, newIndex).addChild();

      return newChild.addChild.bind(newChild);
    }], [-1, function () {
      var newChild = _this.addChild({}, newIndex);

      return newChild.addChild.bind(newChild);
    }], [0, function () {
      return _this.addChild.bind(_this);
    }], [1, function (controlData) {
      var currentIndex = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* indexOfNode */ "f"])(_this.dom);
      return function () {
        return _this.parent.addChild(controlData, currentIndex + 1);
      };
    }], [2, function (controlData) {
      return function () {
        return _this.parent.parent.addChild(controlData);
      };
    }]]);
    var onAddConditions = {
      controls: function controls() {
        var _Controls$get = _controls__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].get(item.id),
            controlData = _Controls$get.controlData;

        var metaId = controlData.meta.id;
        var controlType = metaId.startsWith('layout-') ? metaId.replace(/^layout-/, '') : 'field';
        var targets = {
          stage: {
            row: 0,
            column: -1,
            field: -2
          },
          row: {
            row: 1,
            column: 0,
            field: -1
          },
          column: {
            row: 2,
            column: 1,
            field: 0
          },
          field: 1
        };
        var depth = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(targets, _this.name + "." + controlType);
        var action = depthMap.get(depth)();
        _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].remove(item);
        var component = action(controlData, newIndex);
        return component;
      },
      row: function row() {
        var targets = {
          stage: -1,
          row: 0,
          column: 1
        };
        var action = (depthMap.get(targets[toType]) || lodash_identity__WEBPACK_IMPORTED_MODULE_0___default.a)();
        return action && action({
          id: item.id
        }, newIndex);
      },
      column: function column() {
        var targets = {
          stage: -2,
          row: -1
        };
        var action = (depthMap.get(targets[toType]) || lodash_identity__WEBPACK_IMPORTED_MODULE_0___default.a)();
        return action && action(item.id);
      }
    };
    var component = onAddConditions[fromType] && onAddConditions[fromType](item, newIndex);
    defaultOnAdd();
    return component;
  };

  _proto.onRemove = function onRemove(_ref8) {
    var from = _ref8.from.parentElement;

    if (from.classList.contains(_constants__WEBPACK_IMPORTED_MODULE_4__[/* COLUMN_CLASSNAME */ "g"])) {
      from.classList.remove('column-editing-field');
    }

    if (this.name !== 'stage' && !this.children.length) {
      return this.remove();
    }

    this.emptyClass();
    return this.saveChildOrder();
  };

  _proto.onRender = function onRender() {
    var events = this.config.events;

    if (!events) {
      return null;
    }

    events.onRender && _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].onRender(this.dom, events.onRender);
  };

  _proto.getComponent = function getComponent(path) {
    var _path$split = path.split('.'),
        type = _path$split[0],
        id = _path$split[1];

    var group = _index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"][type];
    return id === this.id ? this : group && group.get(id);
  };

  _createClass(Component, [{
    key: "js",
    get: function get() {
      return this.data;
    }
  }, {
    key: "json",
    get: function get() {
      return this.data;
    }
  }, {
    key: "buttons",
    get: function get() {
      var _this4 = this;

      var _this = this;

      var parseIcons = function parseIcons(icons) {
        return icons.map(function (icon) {
          return _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].icon(icon);
        });
      };

      var buttonConfig = {
        handle: function handle(icons) {
          if (icons === void 0) {
            icons = ['move', 'handle'];
          }

          return _objectSpread({}, _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].btnTemplate({
            content: parseIcons(icons)
          }), {
            className: ['item-handle'],
            meta: {
              id: 'handle'
            }
          });
        },
        edit: function edit(icons) {
          if (icons === void 0) {
            icons = ['edit'];
          }

          return _objectSpread({}, _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].btnTemplate({
            content: parseIcons(icons)
          }), {
            className: ['item-edit-toggle'],
            meta: {
              id: 'edit'
            },
            action: {
              click: function click(evt) {
                _this.toggleEdit();
              }
            }
          });
        },
        remove: function remove(icons) {
          if (icons === void 0) {
            icons = ['remove'];
          }

          return _objectSpread({}, _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].btnTemplate({
            content: parseIcons(icons)
          }), {
            className: ['item-remove'],
            meta: {
              id: 'remove'
            },
            action: {
              click: function click(evt, id) {
                _common_animation__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].slideUp(_this.dom, _constants__WEBPACK_IMPORTED_MODULE_4__[/* ANIMATION_SPEED_BASE */ "a"], function () {
                  if (_this.name === 'column') {
                    var row = _this.parent;
                    row.autoColumnWidths();

                    _this.remove();
                  } else {
                    _this.remove();
                  }
                });
              }
            }
          });
        },
        clone: function clone(icons) {
          if (icons === void 0) {
            icons = ['copy'];
          }

          return _objectSpread({}, _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].btnTemplate({
            content: parseIcons(icons)
          }), {
            className: ['item-clone'],
            meta: {
              id: 'clone'
            },
            action: {
              click: function click() {
                return _this4.clone();
              }
            }
          });
        }
      };
      return this.config.actionButtons.buttons.map(function (btn) {
        var _btn$split = btn.split('|'),
            key = _btn$split[0],
            rest = _btn$split.slice(1);

        var icons = rest.length ? rest : undefined;
        return buttonConfig[key] && buttonConfig[key](icons) || btn;
      });
    }
  }, {
    key: "index",
    get: function get() {
      return Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* indexOfNode */ "f"])(this.dom);
    }
  }, {
    key: "parentType",
    get: function get() {
      return _constants__WEBPACK_IMPORTED_MODULE_4__[/* PARENT_TYPE_MAP */ "C"].get(this.name);
    }
  }, {
    key: "parent",
    get: function get() {
      var parentType = this.parentType;

      if (!this.dom || !parentType) {
        return null;
      }

      var parentDom = this.dom.closest("." + _constants__WEBPACK_IMPORTED_MODULE_4__[/* COMPONENT_TYPE_CLASSNAMES */ "j"][parentType]);
      return parentDom && _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].asComponent(parentDom);
    }
  }, {
    key: "children",
    get: function get() {
      if (!this.dom) {
        return [];
      }

      var domChildren = this.domChildren;
      var childGroup = _constants__WEBPACK_IMPORTED_MODULE_4__[/* CHILD_TYPE_MAP */ "f"].get(this.name);
      return Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* map */ "i"])(domChildren, function (child) {
        return _index__WEBPACK_IMPORTED_MODULE_5__[/* default */ "e"].getAddress(childGroup + "s." + child.id);
      }).filter(Boolean);
    }
  }, {
    key: "domChildren",
    get: function get() {
      var childWrap = this.dom.querySelector('.children');
      return childWrap ? childWrap.children : [];
    }
  }, {
    key: "config",
    set: function set(config) {
      var metaId = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(this.data, 'meta.id');
      var allConfig = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(config, 'all');
      var typeConfig = metaId && Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(config, metaId);
      var idConfig = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(config, this.id);
      var mergedConfig = [allConfig, typeConfig, idConfig].reduce(function (acc, cur) {
        return cur ? Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* merge */ "h"])(acc, cur) : acc;
      }, this.configVal);
      this.configVal = mergedConfig;
      return this.configVal;
    },
    get: function get() {
      return this.configVal;
    }
  }]);

  return Component;
}(_data__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]);



/***/ }),
/* 16 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(105),
    getValue = __webpack_require__(111);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var lodash_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var lodash_identity__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_identity__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var mi18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var mi18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mi18n__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);





var defaultActions = {
  add: {
    attr: function attr(evt) {
      var attr = window.prompt(evt.message.attr);

      if (attr && evt.isDisabled(attr)) {
        window.alert(mi18n__WEBPACK_IMPORTED_MODULE_1___default.a.get('attributeNotPermitted', attr || ''));
        return actions.add.attrs(evt);
      }

      var val;

      if (attr) {
        val = String(window.prompt(evt.message.value, ''));
        evt.addAction(attr, val);
      }
    },
    option: function option(evt) {
      evt.addAction();
    },
    condition: function condition(evt) {
      evt.addAction(evt);
    }
  },
  click: {
    btn: function btn(evt) {
      evt.action();
    }
  },
  save: {
    form: lodash_identity__WEBPACK_IMPORTED_MODULE_0___default.a
  }
};
var actions = {
  init: function init(options) {
    var actionKeys = Object.keys(defaultActions);
    this.opts = actionKeys.reduce(function (acc, key) {
      acc[key] = Object.assign({}, defaultActions[key], options[key]);
      return acc;
    }, options);
    return this;
  },
  add: {
    attrs: function attrs(evt) {
      return actions.opts.add.attr(evt);
    },
    options: function options(evt) {
      return actions.opts.add.option(evt);
    },
    conditions: function conditions(evt) {
      evt.template = Object(_constants__WEBPACK_IMPORTED_MODULE_2__[/* CONDITION_TEMPLATE */ "n"])();
      return actions.opts.add.condition(evt);
    }
  },
  click: {
    btn: function btn(evt) {
      return actions.opts.click.btn(evt);
    }
  },
  save: {
    form: function form(formData) {
      if (actions.opts.sessionStorage) {
        _utils__WEBPACK_IMPORTED_MODULE_3__[/* sessionStorage */ "l"].set(_constants__WEBPACK_IMPORTED_MODULE_2__[/* SESSION_FORMDATA_KEY */ "F"], formData);
      }

      _events__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].formeoSaved({
        formData: formData
      });
      return actions.opts.save.form(formData);
    }
  }
};
/* harmony default export */ __webpack_exports__["a"] = (actions);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(23),
    getRawTag = __webpack_require__(107),
    objectToString = __webpack_require__(108);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Data; });
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _common_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var Data = function () {
  function Data(name, _data) {
    var _this = this;

    if (_data === void 0) {
      _data = Object.create(null);
    }

    _defineProperty(this, "toJSON", function (data, format) {
      return JSON.stringify(data, null, format);
    });

    _defineProperty(this, "get", function (path) {
      return Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(_this.data, path);
    });

    _defineProperty(this, "getChangeType", function (oldVal, newVal) {
      var change = _constants__WEBPACK_IMPORTED_MODULE_4__[/* CHANGE_TYPES */ "d"].find(function (_ref) {
        var condition = _ref.condition;
        return condition(oldVal, newVal);
      }) || {
        type: 'unknown'
      };
      change.desc = !change.type === 'added' ? oldVal + " to " + newVal : newVal;
      return change;
    });

    _defineProperty(this, "add", function (id, data) {
      if (data === void 0) {
        data = Object.create(null);
      }

      var _data2 = data,
          dataId = _data2.id;
      var elemId = id || dataId || Object(_common_utils__WEBPACK_IMPORTED_MODULE_1__[/* uuid */ "n"])();
      return _this.set(elemId, data);
    });

    _defineProperty(this, "remove", function (path) {
      var delPath = path.split('.');
      var delItem = delPath.pop();

      var parent = _this.get(delPath);

      if (Array.isArray(parent)) {
        parent.splice(Number(delItem), 1);
      } else {
        delete parent[delItem];
      }

      return parent;
    });

    _defineProperty(this, "getData", function () {
      return Object.entries(_this.data).reduce(function (acc, _ref2) {
        var key = _ref2[0],
            val = _ref2[1];
        acc[key] = (val === null || val === void 0 ? void 0 : val.data) ? val.getData() : val;
        return acc;
      }, {});
    });

    _defineProperty(this, "setCallbacks", {});

    _defineProperty(this, "configVal", Object.create(null));

    this.name = name;
    this.data = _data;
    this.dataPath = '';
  }

  var _proto = Data.prototype;

  _proto.set = function set(path, newVal) {
    var _this2 = this;

    var oldVal = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* get */ "d"])(this.data, path);

    if (lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(oldVal, newVal)) {
      return this.data;
    }

    var data = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* set */ "k"])(this.data, path, newVal);

    var callBackPath = Array.isArray(path) ? path.join('.') : path;
    var callBackGroups = Object.keys(this.setCallbacks).filter(function (setKey) {
      return new RegExp(setKey).test(callBackPath);
    });
    var cbArgs = {
      newVal: newVal,
      oldVal: oldVal,
      path: path
    };
    callBackGroups.forEach(function (cbGroup) {
      return _this2.setCallbacks[cbGroup].forEach(function (cb) {
        return cb(cbArgs);
      });
    });

    if (!this.disableEvents) {
      var change = this.getChangeType(oldVal, newVal);
      var evtData = {
        entity: this,
        dataPath: this.dataPath.replace(/\.+$/, ''),
        changePath: this.dataPath + path,
        value: newVal,
        data: data,
        change: change.type + ": " + change.desc,
        src: this.dom
      };

      if (oldVal) {
        evtData.previousValue = oldVal;
      }

      _common_events__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].formeoUpdated(evtData);
    }

    return data;
  };

  _proto.addSetCallback = function addSetCallback(path, cb) {
    if (this.setCallbacks[path]) {
      this.setCallbacks[path].push(cb);
    } else {
      this.setCallbacks[path] = [cb];
    }
  };

  _proto.removeSetCallback = function removeSetCallback(path, cb) {
    this.setCallbacks[path] = this.setCallbacks[path].filter(function (setCb) {
      return setCb !== cb;
    });
  };

  _proto.empty = function empty() {
    this.data = Object.create(null);
  };

  _createClass(Data, [{
    key: "size",
    get: function get() {
      return Object.keys(this.data).length;
    }
  }, {
    key: "js",
    get: function get() {
      return this.data;
    }
  }, {
    key: "json",
    get: function get() {
      return this.data;
    }
  }]);

  return Data;
}();



/***/ }),
/* 22 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(53),
    baseAssignValue = __webpack_require__(45);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(151);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var debounce = __webpack_require__(169),
    isObject = __webpack_require__(9);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(172);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),
/* 28 */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"formeo\",\"version\":\"1.6.0\",\"main\":\"dist/formeo.min.js\",\"files\":[\"dist/*\",\"demo/**/*\"],\"homepage\":\"https://formeo.io\",\"repository\":{\"url\":\"https://github.com/Draggable/formeo\",\"type\":\"git\"},\"author\":\"Draggable https://draggable.io\",\"contributors\":[{\"name\":\"Kevin Chappell\",\"email\":\"kevin.b.chappell@gmail.com\",\"url\":\"https://kevin-chappell.com\"}],\"bugs\":{\"url\":\"https://github.com/draggable/formeo/issues\"},\"description\":\"A zero dependency JavaScript module for drag and drop form creation.\",\"keywords\":[\"drag and drop\",\"form builder\",\"form maker\",\"forms\"],\"license\":\"MIT\",\"ignore\":[\"**/*\",\"node_modules\",\"test\"],\"config\":{\"files\":{\"test\":[\"test/**/*.spec.js\"],\"formeo-editor\":{\"js\":\"src/js/editor.js\"},\"formeo-renderer\":{\"js\":\"src/js/renderer.js\"},\"site\":[\"demo/assets/sass/site.scss\"]}},\"babel\":{\"presets\":[[\"@babel/preset-env\",{\"targets\":{\"browsers\":[\">1%\"]},\"loose\":true}]],\"comments\":false,\"plugins\":[\"@babel/plugin-proposal-object-rest-spread\",\"@babel/plugin-proposal-class-properties\",\"@babel/plugin-proposal-optional-chaining\"]},\"scripts\":{\"analyze\":\"webpack --mode production -p --progress --config tools/webpack.config --analyze\",\"build\":\"npm-run-all -p build:icons build:formeo\",\"build:formeo\":\"cross-env NODE_ENV=production webpack --mode production -p --progress --config tools/webpack.config\",\"build:icons\":\"babel-node ./tools/generate-sprite\",\"lint\":\"eslint ./src --ext .js || true\",\"test\":\"jest src/\",\"test:ci\":\"yarn test --coverage\",\"start\":\"npm-run-all build:icons start:demo\",\"start:demo\":\"cross-env NODE_ENV=development webpack-dev-server --mode development --open --config tools/webpack.config --copy\",\"semantic-release\":\"semantic-release --ci --debug\",\"travis-deploy-once\":\"travis-deploy-once --pro\",\"prepush\":\"yarn test\",\"defaults\":\"webpack-defaults\"},\"devDependencies\":{\"@babel/cli\":\"^7.2.3\",\"@babel/core\":\"^7.4.0\",\"@babel/node\":\"^7.2.2\",\"@babel/plugin-proposal-class-properties\":\"^7.4.0\",\"@babel/plugin-proposal-object-rest-spread\":\"^7.4.0\",\"@babel/plugin-proposal-optional-chaining\":\"^7.9.0\",\"@babel/preset-env\":\"^7.4.2\",\"@commitlint/cli\":\"^7.5.2\",\"@commitlint/config-angular\":\"^7.5.0\",\"@semantic-release/changelog\":\"3.0.0\",\"@semantic-release/git\":\"7.0.1\",\"@semantic-release/npm\":\"5.0.2\",\"autoprefixer\":\"8.4.1\",\"babel-eslint\":\"^10.0.1\",\"babel-jest\":\"^24.5.0\",\"babel-loader\":\"^8.0.5\",\"clean-webpack-plugin\":\"1.0.0\",\"compression-webpack-plugin\":\"1.1.11\",\"copy-webpack-plugin\":\"4.6.0\",\"cross-env\":\"^5.2.0\",\"css-loader\":\"0.28.11\",\"enzyme\":\"^3.9.0\",\"enzyme-to-json\":\"3.3.4\",\"eslint\":\"4.19.1\",\"eslint-config-prettier\":\"2.9.0\",\"eslint-config-standard\":\"11.0.0\",\"eslint-loader\":\"2.0.0\",\"eslint-plugin-css-modules\":\"2.7.5\",\"eslint-plugin-import\":\"2.11.0\",\"eslint-plugin-jest\":\"21.20.2\",\"eslint-plugin-node\":\"6.0.1\",\"eslint-plugin-prettier\":\"2.6.0\",\"eslint-plugin-promise\":\"3.7.0\",\"eslint-plugin-react\":\"7.7.0\",\"eslint-plugin-standard\":\"3.1.0\",\"formeo-i18n\":\"^2.1.3\",\"fs-extra\":\"^7.0.1\",\"html-webpack-harddisk-plugin\":\"1.0.1\",\"html-webpack-plugin\":\"3.2.0\",\"husky\":\"^2.3.0\",\"jest\":\"^24.5.0\",\"lint-staged\":\"7.3.0\",\"lodash\":\"^4.17.11\",\"mi18n\":\"^0.4.8\",\"mini-css-extract-plugin\":\"^0.9.0\",\"node-sass\":\"^4.11.0\",\"npm-run-all\":\"^4.1.5\",\"optimize-css-assets-webpack-plugin\":\"5.0.1\",\"postcss-loader\":\"2.1.4\",\"prettier\":\"1.14.2\",\"raw-loader\":\"^2.0.0\",\"sass-loader\":\"7.0.1\",\"semantic-release\":\"^15.13.4\",\"style-loader\":\"0.21.0\",\"svg-sprite\":\"^1.5.0\",\"travis-deploy-once\":\"^5.0.11\",\"uglifyjs-webpack-plugin\":\"2.0.1\",\"uuid\":\"3.3.2\",\"webpack\":\"^4.32.2\",\"webpack-bundle-analyzer\":\"^3.3.2\",\"webpack-cli\":\"^3.3.2\",\"webpack-dev-server\":\"^3.4.1\"},\"engines\":{},\"dependencies\":{\"sortablejs\":\"1.10.2\"},\"lint-staged\":{\"src/**/*.js\":[\"prettier --config package.json --write\",\"git add\"]},\"prettier\":{\"singleQuote\":true,\"trailingComma\":\"es5\",\"printWidth\":120,\"semi\":false},\"jest\":{\"browser\":true,\"setupFiles\":[\"<rootDir>/jest.setup.js\"],\"snapshotSerializers\":[\"enzyme-to-json/serializer\"],\"transform\":{\"^.+\\\\.(js|jsx|ts|tsx)$\":\"babel-jest\"},\"transformIgnorePatterns\":[\"node_modules/\"],\"coverageReporters\":[\"text\"],\"testRegex\":\"src/.*\\\\.spec\\\\.js$\",\"testURL\":\"http://localhost\"},\"release\":{\"branch\":\"master\",\"verifyConditions\":[\"@semantic-release/changelog\",\"@semantic-release/npm\",\"@semantic-release/git\"],\"prepare\":[\"@semantic-release/changelog\",\"@semantic-release/npm\",\"@semantic-release/git\"]},\"husky\":{\"hooks\":{\"commit-msg\":\"commitlint -E HUSKY_GIT_PARAMS\",\"pre-commit\":\"lint-staged\",\"pre-push\":\"npm run lint\"}},\"commitlint\":{\"extends\":[\"@commitlint/config-angular\"],\"rules\":{\"type-enum\":[2,\"always\",[\"build\",\"chore\",\"ci\",\"docs\",\"feat\",\"fix\",\"perf\",\"refactor\",\"revert\",\"style\",\"test\"]]}}}");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(95),
    listCacheDelete = __webpack_require__(96),
    listCacheGet = __webpack_require__(97),
    listCacheHas = __webpack_require__(98),
    listCacheSet = __webpack_require__(99);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(22);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(120);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(43),
    isLength = __webpack_require__(73);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(10),
    stubFalse = __webpack_require__(130);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)(module)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(75),
    baseKeysIn = __webpack_require__(135),
    isArrayLike = __webpack_require__(33);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(20),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(186),
    Map = __webpack_require__(42),
    Promise = __webpack_require__(187),
    Set = __webpack_require__(188),
    WeakMap = __webpack_require__(189),
    baseGetTag = __webpack_require__(20),
    toSource = __webpack_require__(63);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var createCompounder = __webpack_require__(55);

/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */
var lowerCase = createCompounder(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});

module.exports = lowerCase;


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Panels; });
/* harmony import */ var mi18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var mi18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mi18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _common_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _common_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var defaults = Object.freeze({
  type: 'field',
  displayType: 'slider'
});

var getTransition = function getTransition(val) {
  return {
    transform: "translateX(" + (val ? val + "px" : 0) + ")"
  };
};

var Panels = function () {
  function Panels(options) {
    var _this2 = this;

    _defineProperty(this, "toggleTabbedLayout", function () {
      _this2.getPanelDisplay();

      var isTabbed = _this2.isTabbed;

      _this2.panelsWrap.parentElement.classList.toggle('tabbed-panels', isTabbed);

      if (isTabbed) {
        _this2.panelNav.removeAttribute('style');
      }

      return isTabbed;
    });

    _defineProperty(this, "resizePanels", function () {
      _this2.toggleTabbedLayout();

      var panelStyle = _this2.panelsWrap.style;
      var activePanelHeight = _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getStyle(_this2.currentPanel, 'height');
      panelStyle.height = activePanelHeight;
      return activePanelHeight;
    });

    this.opts = Object(_common_utils__WEBPACK_IMPORTED_MODULE_5__[/* merge */ "h"])(defaults, options);
    this.panelDisplay = this.opts.displayType;
    this.activePanelIndex = 0;
    this.panelNav = this.createPanelNav();
    var panelsWrap = this.createPanelsWrap();
    this.nav = this.navActions();
    var resizeObserver = new window.ResizeObserver(function (_ref) {
      var width = _ref[0].contentRect.width;

      if (_this2.currentWidth !== width) {
        _this2.toggleTabbedLayout();

        _this2.currentWidth = width;

        _this2.nav.setTranslateX(_this2.activePanelIndex, false);
      }
    });
    var observeTimeout = window.setTimeout(function () {
      resizeObserver.observe(panelsWrap);
      window.clearTimeout(observeTimeout);
    }, _constants__WEBPACK_IMPORTED_MODULE_4__[/* ANIMATION_SPEED_SLOW */ "c"]);
  }

  var _proto = Panels.prototype;

  _proto.getPanelDisplay = function getPanelDisplay() {
    var column = this.panelsWrap;
    var width = parseInt(_common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getStyle(column, 'width'));
    var autoDisplayType = width > 390 ? 'tabbed' : 'slider';
    var isAuto = this.opts.displayType === 'auto';
    this.panelDisplay = isAuto ? autoDisplayType : this.opts.displayType || defaults.displayType;
    return this.panelDisplay;
  };

  _proto.createPanelsWrap = function createPanelsWrap() {
    var panelsWrap = _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].create({
      className: 'panels',
      content: this.opts.panels.map(function (_ref2) {
        var label = _ref2.config.label,
            panel = _objectWithoutPropertiesLoose(_ref2, ["config"]);

        return panel;
      })
    });

    if (this.opts.type === 'field') {
      this.sortableProperties(panelsWrap);
    }

    this.panelsWrap = panelsWrap;
    this.panels = panelsWrap.children;
    this.currentPanel = this.panels[this.activePanelIndex];
    return panelsWrap;
  };

  _proto.sortableProperties = function sortableProperties(panels) {
    var _this = this;

    var groups = panels.getElementsByClassName('field-edit-group');
    return _common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"].forEach(groups, function (group, index) {
      group.fieldId = _this.opts.id;

      if (group.isSortable) {
        sortablejs__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].create(group, {
          animation: 150,
          group: {
            name: 'edit-' + group.editGroup,
            pull: true,
            put: ['properties']
          },
          sort: true,
          handle: '.prop-order',
          onSort: function onSort(evt) {
            _this.propertySave(evt.to);

            _this.resizePanels();
          }
        });
      }
    });
  };

  _proto.createPanelNavLabels = function createPanelNavLabels() {
    var _this3 = this;

    var labels = this.opts.panels.map(function (panel) {
      return {
        tag: 'h5',
        action: {
          click: function click(evt) {
            var index = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* indexOfNode */ "f"])(evt.target, evt.target.parentElement);
            _this3.currentPanel = _this3.panels[index];
            var labels = evt.target.parentElement.childNodes;

            _this3.nav.refresh(index);

            _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].removeClasses(labels, 'active-tab');
            evt.target.classList.add('active-tab');
          }
        },
        content: panel.config.label
      };
    });
    var panelLabels = {
      className: 'panel-labels',
      content: {
        content: labels
      }
    };
    var firstLabel = labels[0];
    firstLabel.className = 'active-tab';
    return _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].create(panelLabels);
  };

  _proto.createPanelNav = function createPanelNav() {
    var _this4 = this;

    this.labels = this.createPanelNavLabels();
    var next = {
      tag: 'button',
      attrs: {
        className: 'next-group',
        title: mi18n__WEBPACK_IMPORTED_MODULE_0___default.a.get('controlGroups.nextGroup'),
        type: 'button'
      },
      dataset: {
        toggle: 'tooltip',
        placement: 'top'
      },
      action: {
        click: function click(e) {
          return _this4.nav.nextGroup(e);
        }
      },
      content: _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].icon('triangle-right')
    };
    var prev = {
      tag: 'button',
      attrs: {
        className: 'prev-group',
        title: mi18n__WEBPACK_IMPORTED_MODULE_0___default.a.get('controlGroups.prevGroup'),
        type: 'button'
      },
      dataset: {
        toggle: 'tooltip',
        placement: 'top'
      },
      action: {
        click: function click(e) {
          return _this4.nav.prevGroup(e);
        }
      },
      content: _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].icon('triangle-left')
    };
    return _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].create({
      tag: 'nav',
      attrs: {
        className: 'panel-nav'
      },
      content: [prev, this.labels, next]
    });
  };

  _proto.navActions = function navActions() {
    var _this5 = this;

    var action = {};
    var groupParent = this.currentPanel.parentElement;
    var labelWrap = this.labels.firstChild;
    var siblingGroups = this.currentPanel.parentElement.childNodes;
    this.activePanelIndex = Object(_common_helpers__WEBPACK_IMPORTED_MODULE_2__[/* indexOfNode */ "f"])(this.currentPanel, groupParent);
    var offset = {
      nav: 0,
      panel: 0
    };

    var lastOffset = _objectSpread({}, offset);

    var groupChange = function groupChange(newIndex) {
      var labels = labelWrap.children;
      _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].removeClasses(siblingGroups, 'active-panel');
      _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].removeClasses(labels, 'active-tab');
      _this5.currentPanel = siblingGroups[newIndex];

      _this5.currentPanel.classList.add('active-panel');

      labels[newIndex].classList.add('active-tab');
      return _this5.currentPanel;
    };

    var getOffset = function getOffset(index) {
      return {
        nav: -labelWrap.offsetWidth * index,
        panel: -groupParent.offsetWidth * index
      };
    };

    var translateX = function translateX(_ref3) {
      var offset = _ref3.offset,
          reset = _ref3.reset,
          _ref3$duration = _ref3.duration,
          duration = _ref3$duration === void 0 ? _constants__WEBPACK_IMPORTED_MODULE_4__[/* ANIMATION_SPEED_FAST */ "b"] : _ref3$duration,
          _ref3$animate = _ref3.animate,
          animate = _ref3$animate === void 0 ? !_this5.isTabbed : _ref3$animate;
      var panelQueue = [getTransition(lastOffset.panel), getTransition(offset.panel)];
      var navQueue = [getTransition(lastOffset.nav), getTransition(_this5.isTabbed ? 0 : offset.nav)];

      if (reset) {
        var panelStart = panelQueue[0];
        var navStart = navQueue[0];
        panelQueue.push(panelStart);
        navQueue.push(navStart);
      }

      var animationOptions = {
        easing: 'ease-in-out',
        duration: animate ? duration : 0,
        fill: 'forwards'
      };
      var panelTransition = groupParent.animate(panelQueue, animationOptions);
      labelWrap.animate(navQueue, animationOptions);

      var handleFinish = function handleFinish() {
        _this5.panelsWrap.style.height = _common_dom__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getStyle(_this5.currentPanel, 'height');
        panelTransition.removeEventListener('finish', handleFinish);

        if (!reset) {
          lastOffset = offset;
        }
      };

      panelTransition.addEventListener('finish', handleFinish);
    };

    action.setTranslateX = function (panelIndex, animate) {
      if (animate === void 0) {
        animate = true;
      }

      offset = getOffset(panelIndex || _this5.activePanelIndex);
      translateX({
        offset: offset,
        animate: animate
      });
    };

    action.refresh = function (newIndex) {
      if (newIndex !== undefined) {
        _this5.activePanelIndex = newIndex;
        groupChange(newIndex);
      }

      _this5.resizePanels();

      action.setTranslateX(_this5.activePanelIndex, false);
    };

    action.nextGroup = function () {
      var newIndex = _this5.activePanelIndex + 1;

      if (newIndex !== siblingGroups.length) {
        var curPanel = groupChange(newIndex);
        offset = {
          nav: -labelWrap.offsetWidth * newIndex,
          panel: -curPanel.offsetLeft
        };
        translateX({
          offset: offset
        });
        _this5.activePanelIndex++;
      } else {
        offset = {
          nav: lastOffset.nav - 8,
          panel: lastOffset.panel - 8
        };
        translateX({
          offset: offset,
          reset: true
        });
      }

      return _this5.currentPanel;
    };

    action.prevGroup = function () {
      if (_this5.activePanelIndex !== 0) {
        var newIndex = _this5.activePanelIndex - 1;
        var curPanel = groupChange(newIndex);
        offset = {
          nav: -labelWrap.offsetWidth * newIndex,
          panel: -curPanel.offsetLeft
        };
        translateX({
          offset: offset
        });
        _this5.activePanelIndex--;
      } else {
        offset = {
          nav: 8,
          panel: 8
        };
        translateX({
          offset: offset,
          reset: true
        });
      }
    };

    return action;
  };

  _createClass(Panels, [{
    key: "isTabbed",
    get: function get() {
      return this.panelDisplay === 'tabbed';
    }
  }]);

  return Panels;
}();



/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../node_modules/mi18n/dist/mi18n.min.js
var mi18n_min = __webpack_require__(2);
var mi18n_min_default = /*#__PURE__*/__webpack_require__.n(mi18n_min);

// EXTERNAL MODULE: ../node_modules/lodash/startCase.js
var startCase = __webpack_require__(8);
var startCase_default = /*#__PURE__*/__webpack_require__.n(startCase);

// EXTERNAL MODULE: ../node_modules/lodash/throttle.js
var throttle = __webpack_require__(26);
var throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);

// EXTERNAL MODULE: ../src/js/common/dom.js
var dom = __webpack_require__(0);

// EXTERNAL MODULE: ../src/js/components/panels.js
var panels = __webpack_require__(39);

// EXTERNAL MODULE: ../src/js/common/utils.js
var utils = __webpack_require__(3);

// EXTERNAL MODULE: ../src/js/common/actions.js
var common_actions = __webpack_require__(19);

// EXTERNAL MODULE: ../node_modules/lodash/lowerCase.js
var lowerCase = __webpack_require__(38);
var lowerCase_default = /*#__PURE__*/__webpack_require__.n(lowerCase);

// EXTERNAL MODULE: ../src/js/common/helpers.js
var helpers = __webpack_require__(4);

// EXTERNAL MODULE: ../src/js/common/animation.js
var animation = __webpack_require__(7);

// EXTERNAL MODULE: ../src/js/constants.js
var constants = __webpack_require__(1);

// EXTERNAL MODULE: ../src/js/common/events.js
var events = __webpack_require__(6);

// EXTERNAL MODULE: ../src/js/components/index.js + 10 modules
var components = __webpack_require__(5);

// CONCATENATED MODULE: ../src/js/components/autocomplete.js
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







var BASE_NAME = 'f-autocomplete';
var HIGHLIGHT_CLASS_NAME = 'highlight-component';
var lastCache = Date.now();
var optionsCache;
var labelCount = function labelCount(arr, label) {
  return arr.reduce(function (n, x) {
    return n + (x === label);
  }, 0);
};

var autocomplete_getComponentLabel = function getComponentLabel(_ref) {
  var name = _ref.name,
      id = _ref.id,
      component = _objectWithoutPropertiesLoose(_ref, ["name", "id"]);

  var labelPaths = ['config.label', 'attrs.id', 'meta.id'];
  var label = labelPaths.reduce(function (acc, cur) {
    if (!acc) {
      acc = component.get(cur);
    }

    return acc;
  }, null);

  var externalLabel = function externalLabel() {
    for (var _len = arguments.length, externalAddress = new Array(_len), _key = 0; _key < _len; _key++) {
      externalAddress[_key] = arguments[_key];
    }

    return mi18n_min_default.a.get(externalAddress.join('.')) || startCase_default()(externalAddress.join(' '));
  };

  return label || name === 'external' && externalLabel(name, id);
};

var autocomplete_componentOptions = function componentOptions(selected) {
  var labels = [];
  var flatList = components["e" /* default */].flatList();
  var options = Object.entries(flatList).map(function (_ref2) {
    var id = _ref2[0],
        component = _ref2[1];
    var label = autocomplete_getComponentLabel(component);

    if (label) {
      var type = {
        tag: 'span',
        content: " " + startCase_default()(component.name),
        className: 'component-type'
      };
      var labelKey = component.name + "." + label;
      labels.push(labelKey);
      var count = labelCount(labels, labelKey);
      var countConfig = {
        tag: 'span',
        content: count > 1 && "(" + count + ")",
        className: 'component-label-count'
      };
      return dom["a" /* default */].makeOption([id, [label + " ", countConfig, type]], selected);
    }
  });
  return options.filter(Boolean);
};

var autocomplete_Autocomplete = function () {
  function Autocomplete(key, value, i18nKey) {
    this.key = key;
    this.className = key.replace(/\./g, '-');
    this.value = value;
    this.events = [];
    this.i18nKey = i18nKey;
    this.build();
  }

  var _proto = Autocomplete.prototype;

  _proto.build = function build() {
    var _this = this;

    var keyboardNav = function keyboardNav(e) {
      var list = _this.list;

      var activeOption = _this.getActiveOption();

      var keyCodeMap = new Map([[38, function () {
        var previous = _this.getPreviousOption(activeOption);

        if (previous) {
          _this.selectOption(previous);
        }
      }], [40, function () {
        var next = _this.getNextOption(activeOption);

        if (next) {
          _this.selectOption(next);
        }
      }], [13, function () {
        if (activeOption) {
          _this.selectOption(activeOption);

          _this.setValue(activeOption);

          if (list.style.display === 'none') {
            _this.showList(activeOption);
          } else {
            _this.hideList();
          }
        }

        e.preventDefault();
      }], [27, function () {
        _this.hideList();
      }]]);
      var direction = keyCodeMap.get(e.keyCode);

      if (!direction) {
        direction = function direction() {
          return false;
        };
      }

      return direction();
    };

    var autoCompleteInputActions = {
      focus: function focus(_ref3) {
        var target = _ref3.target;

        _this.updateOptions();

        target.parentElement.classList.add(_this.className + "-focused");
        var filteredOptions = dom["a" /* default */].toggleElementsByStr(_this.list.querySelectorAll('li'), target.value);
        target.addEventListener('keydown', keyboardNav);
        var selectedOption = _this.list.querySelector('.active-option') || filteredOptions[0];

        _this.showList(selectedOption);
      },
      blur: function blur(_ref4) {
        var target = _ref4.target;
        target.parentElement.classList.remove(_this.className + "-focused");
        target.removeEventListener('keydown', keyboardNav);

        _this.hideList();
      },
      input: function input(evt) {
        var filteredOptions = dom["a" /* default */].toggleElementsByStr(_this.list.querySelectorAll('li'), evt.target.value);

        if (evt.target.value.length === 0) {
          _this.clearValue();
        }

        if (filteredOptions.length === 0) {
          _this.hideList();
        } else {
          var activeOption = _this.getActiveOption() || filteredOptions[0];

          _this.showList(activeOption);
        }

        _this.hiddenField.value = evt.target.value;
        _this.value = evt.target.value;

        _this.runEvent('onChange', {
          target: _this.hiddenField
        });
      }
    };
    this.displayField = dom["a" /* default */].create({
      tag: 'input',
      autocomplete: 'off',
      action: autoCompleteInputActions,
      attrs: {
        type: 'text',
        className: BASE_NAME + "-display-field",
        value: this.label || this.value,
        placeholder: mi18n_min_default.a.get(this.i18nKey + "." + this.key + ".placeholder")
      }
    });
    this.hiddenField = dom["a" /* default */].create({
      tag: 'input',
      attrs: {
        type: 'hidden',
        className: this.className,
        value: this.value
      }
    });
    this.list = dom["a" /* default */].create({
      tag: 'ul',
      attrs: {
        className: BASE_NAME + "-list"
      }
    });
    this.dom = dom["a" /* default */].create({
      children: [this.displayField, this.hiddenField, this.list],
      className: this.className,
      action: {
        onRender: function onRender() {
          var component = _this.value && components["e" /* default */].getAddress(_this.value);
          _this.label = component && autocomplete_getComponentLabel(component);

          if (_this.label) {
            _this.displayField.value = _this.label;
          }

          _this.updateOptions();
        }
      }
    });
    return this.dom;
  };

  _proto.updateOptions = function updateOptions() {
    var _this2 = this;

    var now = Date.now();

    if (now - lastCache > constants["c" /* ANIMATION_SPEED_SLOW */]) {
      dom["a" /* default */].empty(this.list);
      this.generateOptions();
      lastCache = now;
    }

    var options = optionsCache || this.generateOptions();
    options.forEach(function (option) {
      return _this2.list.appendChild(option);
    });
  };

  _proto.generateOptions = function generateOptions() {
    var _this3 = this;

    var options = autocomplete_componentOptions();

    var realTarget = function realTarget(target) {
      var targetClass = BASE_NAME + "-list-item";

      if (!target.classList.contains(targetClass)) {
        target = target.parentElement;
      }

      return target;
    };

    optionsCache = options.map(function (optionData) {
      var value = optionData.value;
      var _optionData$label = optionData.label,
          label = _optionData$label[0];
      label = label.trim();
      var optionConfig = {
        tag: 'li',
        children: optionData.label,
        dataset: {
          value: value,
          label: label
        },
        className: BASE_NAME + "-list-item",
        action: {
          mousedown: function mousedown(_ref5) {
            var target = _ref5.target;
            target = realTarget(target);

            _this3.setValue(target);

            _this3.selectOption(target);

            _this3.hideList();
          },
          mouseover: function mouseover(_ref6) {
            var target = _ref6.target;
            target = realTarget(target);

            _this3.removeHighlight();

            _this3.highlightComponent(target);
          }
        }
      };
      return dom["a" /* default */].create(optionConfig);
    });
    return optionsCache;
  };

  _proto.hideList = function hideList(list) {
    if (list === void 0) {
      list = this.list;
    }

    animation["a" /* default */].slideUp(list, constants["b" /* ANIMATION_SPEED_FAST */]);
    this.removeHighlight();
  };

  _proto.showList = function showList(selectedOption, list) {
    if (list === void 0) {
      list = this.list;
    }

    this.selectOption(selectedOption);
    animation["a" /* default */].slideDown(list, constants["b" /* ANIMATION_SPEED_FAST */]);
  };

  _proto.getActiveOption = function getActiveOption(list) {
    if (list === void 0) {
      list = this.list;
    }

    var activeOption = list.getElementsByClassName('active-option')[0];

    if (activeOption && activeOption.style.display !== 'none') {
      return activeOption;
    }

    return null;
  };

  _proto.getPreviousOption = function getPreviousOption(current) {
    var previous = current;

    do {
      previous = previous ? previous.previousSibling : null;
    } while (previous != null && previous.style.display === 'none');

    return previous;
  };

  _proto.getNextOption = function getNextOption(current) {
    var next = current;

    do {
      next = next ? next.nextSibling : null;
    } while (next != null && next.style.display === 'none');

    return next;
  };

  _proto.selectOption = function selectOption(selectedOption, list) {
    if (list === void 0) {
      list = this.list;
    }

    var options = list.querySelectorAll('li');

    for (var i = 0; i < options.length; i++) {
      var value = options[i].dataset.value;
      options[i].classList.remove('active-option');

      if (value) {
        var component = components["e" /* default */].getAddress(value);
        component.dom && component.dom.classList.remove(HIGHLIGHT_CLASS_NAME);
      }
    }

    if (selectedOption) {
      selectedOption.classList.add('active-option');
      this.highlightComponent(selectedOption);
    }
  };

  _proto.removeHighlight = function removeHighlight() {
    var highlightedComponents = document.getElementsByClassName(HIGHLIGHT_CLASS_NAME);

    for (var i = 0; i < highlightedComponents.length; i++) {
      highlightedComponents[i].classList.remove(HIGHLIGHT_CLASS_NAME);
    }
  };

  _proto.highlightComponent = function highlightComponent(option) {
    var value = option.dataset.value;

    if (value) {
      var component = components["e" /* default */].getAddress(value);
      component.dom && component.dom.classList.add(HIGHLIGHT_CLASS_NAME);
    }
  };

  _proto.clearValue = function clearValue() {
    this.selectOption(null);
    this.displayField.value = '';
    this.hiddenField.value = '';
    this.value = '';
    this.runEvent('onChange', {
      target: this.hiddenField
    });
  };

  _proto.setValue = function setValue(target) {
    var _target$dataset = target.dataset,
        label = _target$dataset.label,
        value = _target$dataset.value;
    this.displayField.value = label;
    this.hiddenField.value = value;
    this.value = value;
    this.runEvent('onChange', {
      target: this.hiddenField
    });
  };

  _proto.addEvent = function addEvent(key, event) {
    this.events.push([key, event]);
  };

  _proto.runEvent = function runEvent(eventName, evt) {
    this.events.forEach(function (_ref7) {
      var key = _ref7[0],
          event = _ref7[1];

      if (key === eventName) {
        event(evt);
      }
    });
  };

  return Autocomplete;
}();


// CONCATENATED MODULE: ../src/js/components/fields/edit-panel-item.js
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var edit_panel_item_getOptionData = function getOptionData(key) {
  var isExternal = Object(utils["f" /* isExternalAddress */])(key);

  var optionDataMap = _objectSpread({
    'field.property': constants["A" /* FIELD_PROPERTY_MAP */]
  }, constants["B" /* OPERATORS */]);

  var externalOptionData = function externalOptionData(address) {
    return components["e" /* default */].getAddress(address).getData();
  };

  var data = isExternal ? externalOptionData(key) : optionDataMap[key];
  return Object.keys(data).reduce(function (acc, cur) {
    acc[cur] = cur;
    return acc;
  }, {});
};

var edit_panel_item_createOptions = function createOptions(fieldVal, selected) {
  var data = edit_panel_item_getOptionData(fieldVal);
  return Object.entries(data).reduce(function (acc, _ref) {
    var key = _ref[0],
        value = _ref[1];

    if (key !== 'id') {
      var option = {
        tag: 'option',
        content: mi18n_min_default.a.get(fieldVal + "." + key) || lowerCase_default()(key),
        attrs: {
          value: value
        }
      };

      if (selected === value) {
        option.attrs.selected = true;
      }

      acc.push(dom["a" /* default */].create(option));
    }

    return acc;
  }, []);
};

var edit_panel_item_addOptions = function addOptions(select, options) {
  dom["a" /* default */].empty(select);
  options.forEach(function (option) {
    return select.add(option);
  });
};

var edit_panel_item_inputConfigBase = function inputConfigBase(_ref2) {
  var key = _ref2.key,
      value = _ref2.value,
      _ref2$type = _ref2.type,
      type = _ref2$type === void 0 ? 'text' : _ref2$type,
      checked = _ref2.checked;
  var config = {
    tag: 'input',
    attrs: {
      type: type,
      value: value,
      placeholder: mi18n_min_default.a.get(key + ".placeholder") || startCase_default()(key)
    },
    className: key.replace(/\./g, '-'),
    config: {}
  };

  if (checked) {
    config.attrs.checked = true;
  }

  return config;
};

var edit_panel_item_labelHelper = function labelHelper(key) {
  var labelText = mi18n_min_default.a.get(key);

  if (labelText) {
    return labelText;
  }

  var splitKey = key.split('.');
  return mi18n_min_default.a.get(splitKey[splitKey.length - 1]);
};

var ITEM_INPUT_TYPE_MAP = {
  autocomplete: function autocomplete(key, val, type) {
    return new autocomplete_Autocomplete(key, val, type);
  },
  string: function string(key, val) {
    return edit_panel_item_inputConfigBase({
      key: key,
      value: val
    });
  },
  boolean: function boolean(key, val) {
    var type = key === 'selected' ? 'radio' : 'checkbox';
    return edit_panel_item_inputConfigBase({
      key: key,
      value: val,
      type: type,
      checked: val
    });
  },
  number: function number(key, val) {
    return edit_panel_item_inputConfigBase({
      key: key,
      value: val,
      type: 'number'
    });
  },
  array: function array(key, vals) {
    if (vals === void 0) {
      vals = [];
    }

    return {
      tag: 'select',
      attrs: {
        placeholder: edit_panel_item_labelHelper("placeholder." + key)
      },
      className: key.replace(/\./g, '-'),
      options: vals
    };
  },
  object: function object(val) {
    return Object.entries(val).map(function (_ref3) {
      var key = _ref3[0],
          val = _ref3[1];
      return ITEM_INPUT_TYPE_MAP[dom["a" /* default */].childType(val)](key, val);
    });
  }
};
var INPUT_ORDER = ['selected', 'checked'];
var INPUT_TYPE_ACTION = {
  boolean: function boolean(dataKey, field) {
    return {
      click: function click(_ref4) {
        var _field$data, _field$data$attrs;

        var checked = _ref4.target.checked;

        if (((_field$data = field.data) === null || _field$data === void 0 ? void 0 : (_field$data$attrs = _field$data.attrs) === null || _field$data$attrs === void 0 ? void 0 : _field$data$attrs.type) === 'radio') {
          field.set('options', field.data.options.map(function (option) {
            return _objectSpread({}, option, {
              selected: false
            });
          }));
        }

        field.set(dataKey, checked);
        field.updatePreview();
      }
    };
  },
  string: function string(dataKey, field) {
    return {
      input: function input(_ref5) {
        var value = _ref5.target.value;
        field.set(dataKey, value);
        field.updatePreview();
      }
    };
  },
  number: function number(dataKey, field) {
    return {
      input: function input(_ref6) {
        var value = _ref6.target.value;
        field.set(dataKey, Number(value));
        field.updatePreview();
      }
    };
  },
  array: function array(dataKey, field) {
    return {
      change: function change(_ref7) {
        var value = _ref7.target.value;
        field.set(dataKey, value);
        field.updatePreview();
      }
    };
  },
  object: function object() {
    return {};
  }
};

var edit_panel_item_EditPanelItem = function () {
  function EditPanelItem(_ref8) {
    var _this = this;

    var _key = _ref8.key,
        data = _ref8.data,
        index = _ref8.index,
        _field = _ref8.field;

    _defineProperty(this, "generateConditionFields", function (type, vals) {
      var label = {
        tag: 'label',
        className: "condition-label " + type + "-condition-label",
        content: mi18n_min_default.a.get(type) || type
      };
      return vals.map(function (condition, i) {
        var conditionState = [];
        var fields = Object.entries(condition).map(function (_ref9) {
          var key = _ref9[0],
              val = _ref9[1];

          var field = _this.conditionInput(key, val, type, i);

          field && conditionState.push([field.className, val.trim()].filter(Boolean).join('-'));
          return field;
        }).filter(Boolean);
        var orderedFields = Object(helpers["j" /* orderObjectsBy */])(fields, constants["m" /* CONDITION_INPUT_ORDER */].map(function (fieldName) {
          return "condition-" + fieldName;
        }), 'className||dom.className');

        _this.processConditionUIState(orderedFields);

        if (!i) {
          orderedFields.unshift(label);
        }

        _this.itemFieldGroups.push(orderedFields);

        return {
          children: orderedFields,
          className: "f-condition-row " + type + "-condition-row " + conditionState.join(' ')
        };
      });
    });

    _defineProperty(this, "processConditionUIState", function (fields) {
      var findFields = function findFields(classNames) {
        classNames = classNames.split('|');
        return fields.filter(function (field) {
          return classNames.includes(field.className);
        });
      };

      var hideFields = function hideFields(fields) {
        fields = Array.isArray(fields) ? fields : [fields];
        var hideFieldsTimeout = setTimeout(function () {
          fields.forEach(function (field) {
            if (field.dom) {
              field = field.dom;
            }

            field.style.display = 'none';
          });
          clearTimeout(hideFieldsTimeout);
        }, constants["a" /* ANIMATION_SPEED_BASE */]);
      };

      var showFields = function showFields(fields) {
        fields = Array.isArray(fields) ? fields : [fields];
        var showFieldsTimeout = setTimeout(function () {
          fields.forEach(function (field) {
            if (field.dom) {
              field = field.dom;
            }

            field.removeAttribute('style');
          });
          clearTimeout(showFieldsTimeout);
        }, constants["a" /* ANIMATION_SPEED_BASE */]);
      };

      var actions = new Map([['condition-source', function (field) {
        var foundFields = findFields('condition-sourceProperty');
        var sourceProperty = foundFields[0];
        var key = Object(utils["f" /* isExternalAddress */])(field.value) ? field.value : 'field.property';
        var externalProperties = edit_panel_item_createOptions(key, sourceProperty.value);
        edit_panel_item_addOptions(sourceProperty, externalProperties);

        if (field.value) {
          return showFields(foundFields);
        }

        return hideFields(foundFields);
      }], ['condition-target', function (field) {
        var foundFields = findFields('condition-targetProperty');

        if (Object(utils["d" /* isAddress */])(field.value) && field.value) {
          return showFields(foundFields);
        }

        return hideFields(foundFields);
      }], ['condition-sourceProperty', function (field) {
        var foundFields = findFields('condition-comparison|condition-targetProperty|condition-target');
        var val = field.value;
        var key = val.substring(val.lastIndexOf('.') + 1, val.length);

        if (!Object(utils["e" /* isBoolKey */])(key)) {
          return showFields(foundFields);
        }

        return hideFields(foundFields);
      }]]);
      fields.forEach(function (field) {
        var action = actions.get(field.className);

        if (action) {
          action(field);
        }
      });
    });

    _defineProperty(this, "conditionInput", function (key, val, conditionType, i) {
      var field = _this.field;
      var conditionPath = _this.itemKey + "." + conditionType + "." + i;
      var conditionAddress = _this.field.id + "." + conditionPath;
      var dataPath = field.name + "s." + conditionAddress + "." + key;

      var createConditionSelect = function createConditionSelect(key, propertyValue, i18nKey) {
        var options = edit_panel_item_createOptions(i18nKey || key, propertyValue);
        var propertyFieldConfig = ITEM_INPUT_TYPE_MAP['array']("condition." + key);
        propertyFieldConfig.action = {
          change: conditionChangeAction,
          onRender: function onRender(elem) {
            return conditionChangeAction({
              target: elem
            });
          }
        };
        var field = dom["a" /* default */].create(propertyFieldConfig);
        edit_panel_item_addOptions(field, options);
        return field;
      };

      var conditionChangeAction = function conditionChangeAction(_ref10) {
        var target = _ref10.target;
        var row = target.closest('.f-condition-row');
        var regex = new RegExp(target.className + "(?:\\S?)+", 'gm');
        row.className = row.className.replace(regex, '');
        row.classList.add([target.className, target.value].filter(Boolean).join('-'));
        var evtData = {
          dataPath: dataPath,
          value: target.value,
          src: target
        };
        events["a" /* default */].formeoUpdated(evtData);
        components["e" /* default */].setAddress(dataPath, target.value);
        var conditionRow = target.closest('.f-condition-row');
        var rowIndex = Object(helpers["f" /* indexOfNode */])(conditionRow);

        _this.processConditionUIState(_this.itemFieldGroups[rowIndex]);
      };

      var segmentTypes = {
        comparison: function comparison(value) {
          return createConditionSelect('comparison', value);
        },
        logical: function logical(value) {
          return createConditionSelect('logical', value);
        },
        source: function source(value, type) {
          if (type === void 0) {
            type = 'source';
          }

          var componentInput = ITEM_INPUT_TYPE_MAP['autocomplete']("condition." + type, value, conditionType);
          components["e" /* default */].setConditionMap(value, field);
          componentInput.addEvent('onChange', function (evt) {
            components["e" /* default */].removeConditionMap(components["e" /* default */].getAddress(dataPath));
            conditionChangeAction(evt);
            components["e" /* default */].setConditionMap(evt.target.value, field);
          });
          return componentInput;
        },
        sourceProperty: function sourceProperty(value) {
          return createConditionSelect('sourceProperty', value, 'field.property');
        },
        targetProperty: function targetProperty(value) {
          return createConditionSelect('targetProperty', value, 'field.property');
        },
        target: function target(value) {
          return segmentTypes.source(value, 'target');
        },
        value: function value(_value) {
          var valueField = ITEM_INPUT_TYPE_MAP['string']('condition.value', _value);
          valueField.action = {
            input: conditionChangeAction
          };
          return dom["a" /* default */].create(valueField);
        },
        assignment: function assignment(value) {
          return createConditionSelect('assignment', value);
        }
      };
      var conditionField = segmentTypes[key];

      if (conditionField) {
        return segmentTypes[key](val);
      }

      console.error(key + ": invalid condition attribute");
    });

    this.itemValues = Object(helpers["j" /* orderObjectsBy */])(Object.entries(data), INPUT_ORDER, '0');

    var _key$split = _key.split('.'),
        panelName = _key$split[0],
        item = _key$split[1];

    this.field = _field;
    this.itemKey = _key;
    this.itemIndex = index;
    this.panelName = panelName;
    this.isDisabled = _field.isDisabledProp(item, panelName);
    this.isHidden = this.isDisabled && _field.config.panels[panelName].hideDisabled;
    this.isLocked = _field.isLockedProp(item, panelName);
    this.dom = dom["a" /* default */].create({
      tag: 'li',
      className: ["field-" + _key.replace(/\./g, '-'), 'prop-wrap', this.isHidden && 'hidden-property'],
      children: {
        className: 'field-prop',
        children: [this.itemInputs, this.itemControls]
      }
    });
  }

  var _proto = EditPanelItem.prototype;

  _proto.itemInput = function itemInput(key, val) {
    var _this2 = this;

    var valType = dom["a" /* default */].childType(val) || 'string';
    var inputTypeConfig = Object.assign({}, {
      config: {},
      attrs: {}
    }, ITEM_INPUT_TYPE_MAP[valType](key, val));
    var dataKey = this.itemKey.replace(/.\d+$/, function (index) {
      return index + "." + key;
    });
    var labelKey = dataKey.split('.').filter(isNaN).join('.');

    var _map = [[].concat(this.itemKey.split('.'), [key]), [key]].map(function (attrVars) {
      return [_this2.field.id].concat(attrVars).filter(Boolean).join('-');
    }),
        id = _map[0],
        name = _map[1];

    inputTypeConfig.config = Object.assign({}, inputTypeConfig.config, {
      label: this.panelName !== 'options' && edit_panel_item_labelHelper(labelKey),
      labelAfter: false
    });
    inputTypeConfig.attrs = Object.assign({}, inputTypeConfig.attrs, {
      name: inputTypeConfig.attrs.type === 'checkbox' ? name + "[]" : name,
      id: id,
      disabled: this.isDisabled,
      locked: this.isLocked
    });
    inputTypeConfig.action = _objectSpread({}, INPUT_TYPE_ACTION[valType](dataKey, this.field));
    return inputTypeConfig;
  };

  _createClass(EditPanelItem, [{
    key: "itemInputs",
    get: function get() {
      var _this3 = this;

      this.itemFieldGroups = [];
      var inputs = {
        className: this.panelName + "-prop-inputs prop-inputs f-input-group",
        children: this.itemValues.map(function (_ref11) {
          var key = _ref11[0],
              val = _ref11[1];
          var inputConfig = _this3.panelName === 'conditions' ? _this3.generateConditionFields(key, val) : _this3.itemInput(key, val);

          if (['selected', 'checked'].includes(key)) {
            inputConfig = {
              className: 'f-addon',
              children: inputConfig
            };
          }

          return inputConfig;
        })
      };
      return inputs;
    }
  }, {
    key: "itemControls",
    get: function get() {
      var _this4 = this;

      if (this.isLocked) {
        var _controls = {
          className: this.panelName + "-prop-controls prop-controls",
          content: []
        };
        return _controls;
      }

      var remove = {
        tag: 'button',
        attrs: {
          type: 'button',
          className: 'prop-remove prop-control'
        },
        action: {
          click: function click() {
            animation["a" /* default */].slideUp(_this4.dom, 250, function (elem) {
              _this4.field.remove(_this4.itemKey);

              dom["a" /* default */].remove(elem);

              _this4.field.resizePanelWrap();
            });
          }
        },
        content: dom["a" /* default */].icon('remove')
      };
      var controls = {
        className: this.panelName + "-prop-controls prop-controls",
        content: [remove]
      };
      return controls;
    }
  }]);

  return EditPanelItem;
}();


// CONCATENATED MODULE: ../src/js/components/fields/edit-panel.js
function edit_panel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function edit_panel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { edit_panel_ownKeys(Object(source), true).forEach(function (key) { edit_panel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { edit_panel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function edit_panel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function edit_panel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var edit_panel_EditPanel = function () {
  function EditPanel(panelData, panelName, field) {
    var _this2 = this;

    edit_panel_defineProperty(this, "addAttribute", function (attr, val) {
      var _data;

      var safeAttr = Object(helpers["e" /* hyphenCase */])(attr);
      var itemKey = "attrs." + safeAttr;

      if (!mi18n_min_default.a.current[itemKey]) {
        mi18n_min_default.a.put(itemKey, Object(helpers["a" /* capitalize */])(attr));
      }

      if (typeof val === 'string' && ['true', 'false'].includes(val)) {
        val = JSON.parse(val);
      }

      _this2.field.set("attrs." + attr, val);

      var existingAttr = _this2.props.querySelector(".field-attrs-" + safeAttr);

      var newAttr = new edit_panel_item_EditPanelItem({
        key: itemKey,
        data: (_data = {}, _data[safeAttr] = val, _data),
        field: _this2.field
      });

      if (existingAttr) {
        _this2.props.replaceChild(newAttr.dom, existingAttr);
      } else {
        _this2.props.appendChild(newAttr.dom);
      }

      _this2.field.resizePanelWrap();
    });

    edit_panel_defineProperty(this, "addOption", function () {
      var metaId = _this2.field.data.meta.id;

      var fieldOptionData = _this2.field.get('options');

      var type = metaId === 'select' ? 'option' : metaId;
      var newOptionLabel = mi18n_min_default.a.get("newOptionLabel", {
        type: type
      }) || 'New Option';
      var itemKey = "options." + _this2.data.length;
      var optionTemplate = fieldOptionData.length ? Object(utils["a" /* cleanObj */])(fieldOptionData[fieldOptionData.length - 1]) : {};
      var itemData = Object.assign({}, optionTemplate, {
        label: newOptionLabel,
        value: Object(helpers["e" /* hyphenCase */])(newOptionLabel)
      });
      var newOption = new edit_panel_item_EditPanelItem({
        key: itemKey,
        data: itemData,
        field: _this2.field,
        index: _this2.props.children.length
      });

      _this2.editPanelItems.push(newOption);

      _this2.props.appendChild(newOption.dom);

      _this2.field.set(itemKey, itemData);

      _this2.field.resizePanelWrap();
    });

    edit_panel_defineProperty(this, "addCondition", function (evt) {
      var currentConditions = _this2.field.get('conditions');

      var itemKey = "conditions." + currentConditions.length;

      var existingCondition = _this2.props.querySelector(".field-" + itemKey.replace('.', '-'));

      var newCondition = new edit_panel_item_EditPanelItem({
        key: itemKey,
        data: evt.template,
        field: _this2.field
      });

      if (existingCondition) {
        _this2.props.replaceChild(newCondition.dom, existingCondition);
      } else {
        _this2.props.appendChild(newCondition.dom);
      }

      _this2.field.set(itemKey, evt.template);

      _this2.field.resizePanelWrap();
    });

    this.type = dom["a" /* default */].childType(panelData);
    this.data = this.type === 'object' ? Object.entries(panelData) : panelData;
    this.name = panelName;
    this.field = field;
    this.panelConfig = this.getPanelConfig(this.data);

    if (panelName === 'options') {
      field.addSetCallback("^" + panelName, function () {
        _this2.data = field.get('options');

        var _this2$getPanelConfig = _this2.getPanelConfig(_this2.data),
            config = _this2$getPanelConfig.config,
            panelConfig = edit_panel_objectWithoutPropertiesLoose(_this2$getPanelConfig, ["config"]);

        var editPanel = document.getElementById(_this2.panelConfig.id);
        editPanel.replaceWith(dom["a" /* default */].create(panelConfig));
      });
    }
  }

  var _proto = EditPanel.prototype;

  _proto.getPanelConfig = function getPanelConfig(data) {
    this.props = this.createProps(data);
    this.editButtons = this.createEditButtons();
    return {
      id: this.field.id + "-" + this.name + "-panel",
      config: {
        label: mi18n_min_default.a.get("panel.label." + this.name)
      },
      attrs: {
        className: "f-panel " + this.name + "-panel"
      },
      children: [this.props, this.editButtons]
    };
  };

  _proto.createProps = function createProps(data) {
    var _this3 = this;

    this.editPanelItems = Array.from(data).map(function (dataVal, index) {
      var _ref;

      var isArray = _this3.type === 'array';
      var itemKey = [_this3.name, isArray ? String(index) : dataVal[0]].join('.');
      var itemData = isArray ? dataVal : (_ref = {}, _ref[dataVal[0]] = dataVal[1], _ref);
      return new edit_panel_item_EditPanelItem({
        key: itemKey,
        data: itemData,
        field: _this3.field
      });
    });
    var editGroupConfig = {
      tag: 'ul',
      attrs: {
        className: ['field-edit-group', "field-edit-" + this.name]
      },
      editGroup: this.name,
      isSortable: this.name === 'options',
      content: this.editPanelItems
    };
    return dom["a" /* default */].create(editGroupConfig);
  };

  _proto.createEditButtons = function createEditButtons() {
    var _this = this;

    var type = this.name;
    var btnTitle = mi18n_min_default.a.get("panelEditButtons." + type);
    var addActions = {
      attrs: _this.addAttribute,
      options: _this.addOption,
      conditions: _this.addCondition
    };

    var addBtn = edit_panel_objectSpread({}, dom["a" /* default */].btnTemplate({
      content: btnTitle,
      title: btnTitle
    }), {
      className: "add-" + type,
      action: {
        click: function click(evt) {
          var addEvt = {
            btnCoords: dom["a" /* default */].coords(evt.target),
            addAction: addActions[type]
          };

          if (type === 'attrs') {
            addEvt.isDisabled = _this.field.isDisabledProp;
            addEvt.isLocked = _this.field.isLockedProp;
            addEvt.message = {
              attr: mi18n_min_default.a.get("action.add." + type + ".attr"),
              value: mi18n_min_default.a.get("action.add." + type + ".value")
            };
          }

          var eventType = startCase_default()(type);
          var customEvt = new window.CustomEvent("onAdd" + eventType, {
            detail: addEvt
          });
          common_actions["a" /* default */].add[type](addEvt);
          document.dispatchEvent(customEvt);
        }
      }
    });

    var panelEditButtons = {
      className: 'panel-action-buttons',
      content: [addBtn]
    };
    return panelEditButtons;
  };

  return EditPanel;
}();


// EXTERNAL MODULE: ../src/js/components/component.js
var components_component = __webpack_require__(15);

// CONCATENATED MODULE: ../src/js/components/fields/field.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return field_Field; });
function field_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function field_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { field_ownKeys(Object(source), true).forEach(function (key) { field_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { field_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function field_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function field_createClass(Constructor, protoProps, staticProps) { if (protoProps) field_defineProperties(Constructor.prototype, protoProps); if (staticProps) field_defineProperties(Constructor, staticProps); return Constructor; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function field_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var field_DEFAULT_DATA = function DEFAULT_DATA() {
  return {
    conditions: [Object(constants["n" /* CONDITION_TEMPLATE */])()]
  };
};

var field_Field = function (_Component) {
  _inheritsLoose(Field, _Component);

  function Field(fieldData) {
    var _this2;

    if (fieldData === void 0) {
      fieldData = Object.create(null);
    }

    _this2 = _Component.call(this, 'field', Object.assign({}, field_DEFAULT_DATA(), fieldData)) || this;

    field_defineProperty(_assertThisInitialized(_this2), "updateConditionsPanel", function () {
      var updateConditionsTimeout = setTimeout(function () {
        var newConditionsPanel = _this2.editPanels.find(function (_ref) {
          var name = _ref.name;
          return name === 'conditions';
        });

        if (!newConditionsPanel) {
          return null;
        }

        var newProps = newConditionsPanel.createProps();

        var currentConditionsProps = _this2.dom.querySelector('.field-edit-conditions');

        currentConditionsProps.parentElement.replaceChild(newProps, currentConditionsProps);
        clearTimeout(updateConditionsTimeout);
      }, constants["a" /* ANIMATION_SPEED_BASE */]);
    });

    field_defineProperty(_assertThisInitialized(_this2), "updatePreview", throttle_default()(function () {
      if (!_this2.preview.parentElement) {
        return null;
      }

      _this2.updateLabel();

      var newPreview = dom["a" /* default */].create(_this2.fieldPreview(), true);

      _this2.preview.parentElement.replaceChild(newPreview, _this2.preview);

      _this2.preview = newPreview;
    }, constants["a" /* ANIMATION_SPEED_BASE */], {
      leading: false
    }));

    field_defineProperty(_assertThisInitialized(_this2), "isDisabledProp", function (propName, kind) {
      if (kind === void 0) {
        kind = 'attrs';
      }

      var propKind = _this2.config.panels[kind];

      if (!propKind) {
        return false;
      }

      var disabledAttrs = propKind.disabled.concat(_this2.get("config.disabled" + startCase_default()(kind)));
      return disabledAttrs.includes(propName);
    });

    field_defineProperty(_assertThisInitialized(_this2), "isLockedProp", function (propName, kind) {
      if (kind === void 0) {
        kind = 'attrs';
      }

      var propKind = _this2.config.panels[kind];

      if (!propKind) {
        return false;
      }

      var lockedAttrs = propKind.locked.concat(_this2.get("config.locked" + startCase_default()(kind)));
      return lockedAttrs.includes(propName);
    });

    _this2.label = dom["a" /* default */].create(_this2.labelConfig);
    _this2.preview = dom["a" /* default */].create(_this2.fieldPreview());
    _this2.editPanels = [];
    var field = {
      tag: 'li',
      attrs: {
        className: constants["z" /* FIELD_CLASSNAME */]
      },
      id: _this2.id,
      children: [_this2.label, _this2.getActionButtons(), _this2.fieldEdit, _this2.preview],
      panelNav: _this2.panelNav,
      dataset: {
        hoverTag: mi18n_min_default.a.get('field')
      },
      action: {
        mouseenter: function mouseenter() {
          return _this2.dom.classList.add("hovering-" + _this2.name);
        },
        mouseleave: function mouseleave() {
          return _this2.dom.classList.remove("hovering-" + _this2.name);
        }
      }
    };
    field = dom["a" /* default */].create(field);

    _this2.observe(field);

    _this2.dom = field;
    _this2.isEditing = false;

    _this2.onRender(field);

    return _this2;
  }

  var _proto = Field.prototype;

  _proto.updateConditionSourceLabel = function updateConditionSourceLabel(value, label) {
    var newConditionsPanel = this.editPanels.find(function (_ref2) {
      var name = _ref2.name;
      return name === 'conditions';
    });

    if (!newConditionsPanel) {
      return null;
    }

    newConditionsPanel.editPanelItems.forEach(function (_ref3) {
      var itemFieldGroups = _ref3.itemFieldGroups;
      itemFieldGroups.forEach(function (fields) {
        var autocomplete = fields.find(function (field) {
          return field.value === value;
        });

        if (autocomplete) {
          autocomplete.displayField.value = label;
        }
      });
    });
  };

  _proto.set = function set() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var path = args[0],
        value = args[1];

    var data = _Component.prototype.set.call(this, path, value);

    this.updatePreview();
    return data;
  };

  _proto.updateLabel = function updateLabel() {
    if (!this.label) {
      return null;
    }

    var newLabel = dom["a" /* default */].create(this.labelConfig);
    this.label.parentElement.replaceChild(newLabel, this.label);
    this.label = newLabel;
  };

  _proto.fieldPreview = function fieldPreview() {
    var _this$data,
        _this3 = this;

    var prevData = Object(utils["b" /* clone */])(this.data);
    prevData.id = "prev-" + this.id;

    if ((_this$data = this.data) === null || _this$data === void 0 ? void 0 : _this$data.config.editableContent) {
      prevData.attrs = Object.assign({}, prevData.attrs, {
        contenteditable: true
      });
    }

    var fieldPreview = {
      attrs: {
        className: 'field-preview',
        style: this.isEditing && 'display: none;'
      },
      content: dom["a" /* default */].create(prevData, true),
      action: {
        change: function change(evt) {
          var target = evt.target;
          var checked = target.checked,
              type = target.type;

          if (['checkbox', 'radio'].includes(type)) {
            var optionIndex = +target.id.split('-').pop();

            if (type === 'radio') {
              _this3.set('options', _this3.get('options').map(function (option) {
                return field_objectSpread({}, option, {
                  selected: false
                });
              }));
            }

            var checkType = type === 'checkbox' ? 'checked' : 'selected';

            _this3.set("options." + optionIndex + "." + checkType, checked);
          }
        },
        click: function click(evt) {
          if (evt.target.contentEditable === 'true') {
            evt.preventDefault();
          }
        },
        input: function input(evt) {
          if (['input', 'meter', 'progress', 'button'].includes(_this3.data.tag)) {
            _Component.prototype.set.call(_this3, 'attrs.value', evt.target.value);
          }

          if (evt.target.contentEditable) {
            _Component.prototype.set.call(_this3, 'content', evt.target.innerHTML);
          }
        }
      }
    };
    return fieldPreview;
  };

  field_createClass(Field, [{
    key: "labelConfig",
    get: function get() {
      var _this4 = this;

      var hideLabel = !!this.get('config.hideLabel');

      if (hideLabel) {
        return;
      }

      var labelVal = this.get('config.editorLabel') || this.get('config.label');
      var required = this.get('attrs.required');
      var disableHTML = this.config.label.disableHTML;

      var labelConfig = function labelConfig() {
        var config = {
          tag: 'label',
          attrs: {}
        };

        if (disableHTML) {
          config.tag = 'input';
          config.attrs.value = labelVal;
          return config;
        } else {
          config.attrs.contenteditable = true;
          config.children = labelVal;
          return config;
        }
      };

      var label = field_objectSpread({}, labelConfig(), {
        action: {
          input: function input(_ref4) {
            var _ref4$target = _ref4.target,
                innerHTML = _ref4$target.innerHTML,
                innerText = _ref4$target.innerText,
                value = _ref4$target.value;

            _Component.prototype.set.call(_this4, 'config.label', disableHTML ? value : innerHTML);

            var reverseConditionField = components["e" /* default */].getConditionMap("fields." + _this4.id);

            if (reverseConditionField) {
              return reverseConditionField.updateConditionSourceLabel(_this4.name + "s." + _this4.id, disableHTML ? value : innerText);
            }
          }
        }
      });

      var labelWrap = {
        className: 'prev-label',
        children: [label, required && dom["a" /* default */].requiredMark()]
      };
      return labelWrap;
    }
  }, {
    key: "fieldEdit",
    get: function get() {
      var _this5 = this;

      var _this = this;

      this.editPanels = [];
      var editable = ['object', 'array'];
      var noPanels = ['config', 'meta', 'action', 'events'].concat(this.config.panels.disabled);
      var panelOrder = Object(utils["m" /* unique */])([].concat(this.config.panels.order, Object.keys(this.data)));
      var allowedPanels = panelOrder.filter(function (panelName) {
        return !noPanels.includes(panelName);
      });
      var fieldEdit = {
        className: ['field-edit', 'slide-toggle', 'formeo-panels-wrap']
      };
      allowedPanels.forEach(function (panelName) {
        var panelData = _this5.get(panelName);

        var propType = dom["a" /* default */].childType(panelData);

        if (editable.includes(propType)) {
          var editPanel = new edit_panel_EditPanel(panelData, panelName, _this5);

          _this5.editPanels.push(editPanel);
        }
      });
      var panelsData = {
        panels: this.editPanels.map(function (_ref5) {
          var panelConfig = _ref5.panelConfig;
          return panelConfig;
        }),
        id: _this.id,
        displayType: 'auto'
      };
      var editPanelLength = this.editPanels.length;

      if (editPanelLength) {
        this.panels = new panels["a" /* default */](panelsData);
        fieldEdit.className.push("panel-count-" + editPanelLength);
        fieldEdit.content = [this.panels.panelNav, this.panels.panelsWrap];
        this.panelNav = this.panels.nav;
        this.resizePanelWrap = this.panels.nav.refresh;
        fieldEdit.action = {
          onRender: function onRender() {
            _this5.resizePanelWrap();

            if (!editPanelLength) {
              var field = _this5.dom;
              var editToggle = field.querySelector('.item-edit-toggle');
              var fieldActions = field.querySelector('.field-actions');
              var actionButtons = fieldActions.getElementsByTagName('button');
              fieldActions.style.maxWidth = actionButtons.length * actionButtons[0].clientWidth + "px";
              dom["a" /* default */].remove(editToggle);
            }
          }
        };
      }

      return fieldEdit;
    }
  }]);

  return Field;
}(components_component["a" /* default */]);



/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(29),
    stackClear = __webpack_require__(100),
    stackDelete = __webpack_require__(101),
    stackGet = __webpack_require__(102),
    stackHas = __webpack_require__(103),
    stackSet = __webpack_require__(104);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(20),
    isObject = __webpack_require__(9);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(112),
    mapCacheDelete = __webpack_require__(119),
    mapCacheGet = __webpack_require__(121),
    mapCacheHas = __webpack_require__(122),
    mapCacheSet = __webpack_require__(123);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(65);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(68);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(71);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 49 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(132),
    baseUnary = __webpack_require__(51),
    nodeUtil = __webpack_require__(52);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 51 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(62);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)(module)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(45),
    eq = __webpack_require__(22);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(161),
    deburr = __webpack_require__(162),
    words = __webpack_require__(165);

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(183),
    stubArray = __webpack_require__(84);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(75),
    baseKeys = __webpack_require__(184),
    isArrayLike = __webpack_require__(33);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(92);
var bytesToUuid = __webpack_require__(93);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(190);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormeoRenderer; });
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _common_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var RENDER_PREFIX = 'f-';

var processOptions = function processOptions(_ref) {
  var editorContainer = _ref.editorContainer,
      renderContainer = _ref.renderContainer,
      opts = _objectWithoutPropertiesLoose(_ref, ["editorContainer", "renderContainer"]);

  var containerLookup = function containerLookup(container) {
    return typeof container === 'string' ? document.querySelector(container) : container;
  };

  var processedOptions = {
    renderContainer: containerLookup(renderContainer),
    editorContainer: containerLookup(editorContainer)
  };
  return Object.assign({}, opts, processedOptions);
};

var baseId = function baseId(id) {
  var match = id.match(_constants__WEBPACK_IMPORTED_MODULE_3__[/* UUID_REGEXP */ "I"]);
  return match && match[0] || id;
};

var newUUID = function newUUID(id) {
  return id.replace(_constants__WEBPACK_IMPORTED_MODULE_3__[/* UUID_REGEXP */ "I"], Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* uuid */ "n"])());
};

var createRemoveButton = function createRemoveButton() {
  return _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].render(_common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].btnTemplate({
    className: 'remove-input-group',
    children: _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].icon('remove'),
    action: {
      mouseover: function mouseover(_ref2) {
        var target = _ref2.target;
        return target.parentElement.classList.add('will-remove');
      },
      mouseleave: function mouseleave(_ref3) {
        var target = _ref3.target;
        return target.parentElement.classList.remove('will-remove');
      },
      click: function click(_ref4) {
        var target = _ref4.target;
        return target.parentElement.remove();
      }
    }
  }));
};

var FormeoRenderer = function () {
  function FormeoRenderer(opts, _formData) {
    var _this = this;

    _defineProperty(this, "render", function (formData) {
      if (formData === void 0) {
        formData = _this.form;
      }

      _this.form = formData;
      var renderCount = document.getElementsByClassName('formeo-render').length;
      var config = {
        id: _this.form.id,
        className: "formeo-render formeo formeo-rendered-" + renderCount,
        children: _this.processedData
      };
      _this.renderedForm = _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].render(config);
      _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].empty(_this.container);

      _this.applyConditions();

      _this.container.appendChild(_this.renderedForm);
    });

    _defineProperty(this, "orderChildren", function (type, order) {
      return order.reduce(function (acc, cur) {
        return [].concat(acc, [_this.form[type][cur]]);
      }, []);
    });

    _defineProperty(this, "prefixId", function (id) {
      return RENDER_PREFIX + id;
    });

    _defineProperty(this, "processColumn", function (_ref5) {
      var id = _ref5.id,
          className = _ref5.className,
          config = _ref5.config,
          columnData = _objectWithoutPropertiesLoose(_ref5, ["id", "className", "config"]);

      if (columnData.attrs && columnData.attrs.className) {
        className = columnData.attrs.className;
      }

      if (!className.match(_constants__WEBPACK_IMPORTED_MODULE_3__[/* bsColRegExp */ "J"])) {
        var colWidth = Math.round(12 * (parseInt(config.width || 100) / 100));
        className = colWidth === 1 ? className : className + " col-" + colWidth;
      }

      return Object.assign({}, columnData, {
        id: _this.prefixId(id),
        className: config.className ? className + " " + config.className : className,
        children: _this.processFields(columnData.children)
      });
    });

    _defineProperty(this, "processRows", function (stageId) {
      return _this.orderChildren('rows', _this.form.stages[stageId].children).reduce(function (acc, row) {
        return row ? [].concat(acc, [_this.processRow(row)]) : acc;
      }, []);
    });

    _defineProperty(this, "cacheComponent", function (data) {
      _this.components[baseId(data.id)] = data;
      return data;
    });

    _defineProperty(this, "processRow", function (data, type) {
      if (type === void 0) {
        type = 'row';
      }

      var config = data.config,
          id = data.id,
          attrs = data.attrs;
      var className = "formeo-" + type + "-wrap";
      var rowData = Object.assign({}, data, {
        className: attrs && attrs.className || data.className,
        children: _this.processColumns(data.id),
        id: _this.prefixId(id)
      });

      _this.cacheComponent(rowData);

      var configConditions = [{
        condition: config.legend,
        result: function result() {
          return {
            tag: config.fieldset ? 'legend' : 'h3',
            children: config.legend
          };
        }
      }, {
        condition: true,
        result: function result() {
          return rowData;
        }
      }, {
        condition: config.inputGroup,
        result: function result() {
          return _this.addButton(id);
        }
      }];
      var children = configConditions.reduce(function (acc, _ref6) {
        var condition = _ref6.condition,
            result = _ref6.result;
        return condition ? [].concat(acc, [result()]) : acc;
      }, []);

      if (config.inputGroup) {
        className.push(RENDER_PREFIX + 'input-group-wrap');
      }

      return {
        tag: config.fieldset ? 'fieldset' : 'div',
        id: Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* uuid */ "n"])(),
        className: className,
        children: children
      };
    });

    _defineProperty(this, "cloneComponentData", function (componentId) {
      var _this$components$comp = _this.components[componentId],
          _this$components$comp2 = _this$components$comp.children,
          children = _this$components$comp2 === void 0 ? [] : _this$components$comp2,
          id = _this$components$comp.id,
          rest = _objectWithoutPropertiesLoose(_this$components$comp, ["children", "id"]);

      return Object.assign({}, rest, {
        id: newUUID(id),
        children: children.length && children.map(function (_ref7) {
          var id = _ref7.id;
          return _this.cloneComponentData(baseId(id));
        })
      });
    });

    _defineProperty(this, "addButton", function (id) {
      return _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].render({
        tag: 'button',
        attrs: {
          className: 'add-input-group btn pull-right',
          type: 'button'
        },
        children: 'Add +',
        action: {
          click: function click(e) {
            var fInputGroup = e.target.parentElement;
            var elem = _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].render(_this.cloneComponentData(id));
            fInputGroup.insertBefore(elem, fInputGroup.lastChild);
            elem.appendChild(createRemoveButton());
          }
        }
      });
    });

    _defineProperty(this, "processColumns", function (rowId) {
      return _this.orderChildren('columns', _this.form.rows[rowId].children).map(function (column) {
        return _this.cacheComponent(_this.processColumn(column));
      });
    });

    _defineProperty(this, "processFields", function (fieldIds) {
      return _this.orderChildren('fields', fieldIds).map(function (_ref8) {
        var id = _ref8.id,
            field = _objectWithoutPropertiesLoose(_ref8, ["id"]);

        return _this.cacheComponent(Object.assign({}, field, {
          id: _this.prefixId(id)
        }));
      });
    });

    _defineProperty(this, "applyConditions", function () {
      Object.values(_this.components).forEach(function (_ref9) {
        var conditions = _ref9.conditions;

        if (conditions) {
          conditions.forEach(function (condition, i) {
            var ifConditions = condition.if,
                thenConditions = condition.then;
            ifConditions.forEach(function (ifCondition) {
              var source = ifCondition.source,
                  ifRest = _objectWithoutPropertiesLoose(ifCondition, ["source"]);

              if (Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* isAddress */ "d"])(source)) {
                var components = _this.getComponents(source);

                components.forEach(function (component) {
                  var listenerEvent = LISTEN_TYPE_MAP(component);

                  if (listenerEvent) {
                    component.addEventListener(listenerEvent, function (evt) {
                      return _this.evaluateCondition(ifRest, evt) && thenConditions.forEach(function (thenCondition) {
                        return _this.execResult(thenCondition, evt);
                      });
                    }, false);
                  }

                  var fakeEvt = {
                    target: component
                  };
                  _this.evaluateCondition(ifRest, fakeEvt) && thenConditions.forEach(function (thenCondition) {
                    return _this.execResult(thenCondition, fakeEvt);
                  });
                });
              }
            });
          });
        }
      });
    });

    _defineProperty(this, "evaluateCondition", function (_ref10, evt) {
      var sourceProperty = _ref10.sourceProperty,
          targetProperty = _ref10.targetProperty,
          comparison = _ref10.comparison,
          target = _ref10.target;
      var comparisonMap = {
        equals: lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default.a,
        notEquals: function notEquals(source, target) {
          return !lodash_isEqual__WEBPACK_IMPORTED_MODULE_0___default()(source, target);
        },
        contains: function contains(source, target) {
          return source.includes(target);
        },
        notContains: function notContains(source, target) {
          return !source.includes(target);
        }
      };
      var sourceValue = String(evt.target[sourceProperty]);
      var targetValue = String(Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* isAddress */ "d"])(target) ? _this.getComponent(target)[targetProperty] : target);
      return comparisonMap[comparison] && comparisonMap[comparison](sourceValue, targetValue);
    });

    _defineProperty(this, "execResult", function (_ref11) {
      var assignment = _ref11.assignment,
          target = _ref11.target,
          targetProperty = _ref11.targetProperty,
          _value = _ref11.value;
      var assignMap = {
        equals: function equals(elem) {
          var propMap = {
            value: function value() {
              elem[targetProperty] = _value;
            },
            isNotVisible: function isNotVisible() {
              elem.parentElement.setAttribute('hidden', true);
              elem.required = false;
            },
            isVisible: function isVisible() {
              elem.parentElement.removeAttribute('hidden');
              elem.required = elem._required;
            }
          };
          propMap[targetProperty] && propMap[targetProperty]();
        }
      };

      if (Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* isAddress */ "d"])(target)) {
        var elem = _this.getComponent(target);

        if (elem && elem._required === undefined) {
          elem._required = elem.required;
        }

        assignMap[assignment] && assignMap[assignment](elem);
      }
    });

    _defineProperty(this, "getComponent", function (address) {
      var componentId = address.slice(address.indexOf('.') + 1);
      var component = Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* isExternalAddress */ "f"])(address) ? _this.external[componentId] : _this.renderedForm.querySelector("#f-" + componentId);
      return component;
    });

    _defineProperty(this, "getComponents", function (address) {
      var components = [];
      var componentId = address.slice(address.indexOf('.') + 1);

      if (Object(_common_utils__WEBPACK_IMPORTED_MODULE_2__[/* isExternalAddress */ "f"])(address)) {
        components.push(_this.external[componentId]);
      } else {
        components.push.apply(components, _this.renderedForm.querySelectorAll("[name=f-" + componentId + "]"));
      }

      return components;
    });

    var _processOptions = processOptions(opts),
        renderContainer = _processOptions.renderContainer,
        external = _processOptions.external;

    this.container = renderContainer;
    this.form = _formData;
    this.external = external;
    this.components = Object.create(null);
  }

  _createClass(FormeoRenderer, [{
    key: "processedData",
    get: function get() {
      var _this2 = this;

      return Object.values(this.form.stages).map(function (stage) {
        stage.children = _this2.processRows(stage.id);
        stage.className = _constants__WEBPACK_IMPORTED_MODULE_3__[/* STAGE_CLASSNAME */ "H"];
        return _common_dom__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].render(stage);
      });
    }
  }]);

  return FormeoRenderer;
}();



var LISTEN_TYPE_MAP = function LISTEN_TYPE_MAP(component) {
  var typesMap = [['input', function (c) {
    return ['textarea', 'text'].includes(c.type);
  }], ['change', function (c) {
    return ['select'].includes(c.tagName.toLowerCase()) || ['checkbox', 'radio'].includes(c.type);
  }]];

  var _ref12 = typesMap.find(function (typeMap) {
    return typeMap[1](component);
  }) || [false],
      listenerEvent = _ref12[0];

  return listenerEvent;
};

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ../src/sass/formeo.scss
var formeo = __webpack_require__(91);

// EXTERNAL MODULE: ../node_modules/mi18n/dist/mi18n.min.js
var mi18n_min = __webpack_require__(2);
var mi18n_min_default = /*#__PURE__*/__webpack_require__.n(mi18n_min);

// EXTERNAL MODULE: ../src/js/common/dom.js
var dom = __webpack_require__(0);

// EXTERNAL MODULE: ../src/js/common/events.js
var common_events = __webpack_require__(6);

// EXTERNAL MODULE: ../src/js/common/actions.js
var common_actions = __webpack_require__(19);

// EXTERNAL MODULE: ../src/js/components/controls/index.js + 21 modules
var controls = __webpack_require__(12);

// EXTERNAL MODULE: ../src/js/components/index.js + 10 modules
var components = __webpack_require__(5);

// EXTERNAL MODULE: ../src/js/common/loaders.js
var loaders = __webpack_require__(11);

// EXTERNAL MODULE: ../src/js/constants.js
var constants = __webpack_require__(1);

// EXTERNAL MODULE: ../src/js/common/utils.js
var utils = __webpack_require__(3);

// EXTERNAL MODULE: ../src/js/common/helpers.js
var helpers = __webpack_require__(4);

// CONCATENATED MODULE: ../src/js/config.js


mi18n_min_default.a.addLanguage('en-US', "en-US = English\ndir = ltr\n\naction.add.attrs.attr = What attribute would you like to add?\naction.add.attrs.value = Default Value\naddOption = Add Option\nallFieldsRemoved = All fields were removed.\nallowSelect = Allow Select\nattribute = Attribute\nattributes = Attributes\nattrs.class = Class\nattrs.className = Class\nattrs.dir = Direction\nattrs.id = Id\nattrs.required = Required\nattrs.style = Style\nattrs.title = Title\nattrs.type = Type\nattrs.value = Value\nautocomplete = Autocomplete\nbutton = Button\ncannotBeEmpty = This field cannot be empty\ncheckbox = Checkbox\ncheckboxes = Checkboxes\nclass = Class\nclear = Clear\nclearAllMessage = Are you sure you want to clear all fields?\nclose = Close\ncolumn = Column\nconfirmClearAll = Are you sure you want to remove all fields?\ncontent = Content\ncontrol = Control\ncontrolGroups.nextGroup = Next Group\ncontrolGroups.prevGroup = Previous Group\ncontrols.form.button = Button\ncontrols.form.checkbox-group = Checkbox Group\ncontrols.form.input.date = Date\ncontrols.form.input.email = Email\ncontrols.form.input.file = File Upload\ncontrols.form.input.hidden = Hidden Input\ncontrols.form.input.number = Number\ncontrols.form.input.text = Text Input\ncontrols.form.radio-group = Radio Group\ncontrols.form.select = Select\ncontrols.form.textarea = TextArea\ncontrols.groups.form = Form Fields\ncontrols.groups.html = HTML Elements\ncontrols.groups.layout = Layout\ncontrols.html.divider = Divider\ncontrols.html.header = Header\ncontrols.html.paragraph = Paragraph\ncontrols.layout.column = Column\ncontrols.layout.row = Row\ncontrols.filteringTerm = Filtering \"{term}\"\ncopy = Copy To Clipboard\ndanger = Danger\ndescription = Help Text\ndescriptionField = Description\ndefineColumnLayout = Define a column layout\ndefineColumnWidths = Define column widths\nediting.row = Editing Row\neditorTitle = Form Elements\nfield = Field\nfieldNonEditable = This field cannot be edited.\nfieldRemoveWarning = Are you sure you want to remove this field?\nfileUpload = File Upload\nformUpdated = Form Updated\ngetStarted = Drag a field from the right to get started.\ngroup = Group\ngrouped = Grouped\nhidden = Hidden Input\nhide = Edit\nhtmlElements = HTML Elements\nif = If\ninfo = Info\ninput.date = Date\ninput.text = Text\nlabel = Label\nlabelCount = {label} {count}\nlabelEmpty = Field Label cannot be empty\nlayout = Layout\nlimitRole = Limit access to one or more of the following roles:\nmandatory = Mandatory\nmaxlength = Max Length\nmeta.group = Group\nmeta.icon = Ico\nmeta.label = Label\nminOptionMessage = This field requires a minimum of 2 options\nname = Name\nno = No\nnumber = Number\noff = Off\non = On\noption = Option\noptional = optional\noptionEmpty = Option value required\noptionLabel = Option {count}\noptions = Options\norder = Order\npanel.label.attrs = Attributes\npanel.label.conditions = Conditions\npanel.label.config = Configuration\npanel.label.meta = Meta\npanel.label.options = Options\npanelEditButtons.attrs = + Attribute\npanelEditButtons.options = + Option\npanelEditButtons.conditions = + Condition\nplaceholder = Placeholder\nplaceholder.className = space separated classes\nplaceholder.email = Enter you email\nplaceholder.label = Label\nplaceholder.password = Enter your password\nplaceholder.placeholder = Placeholder\nplaceholder.text = Enter some Text\nplaceholder.textarea = Enter a lot of text\nplaceholder.value = Value\npreview = Preview\nprimary = Primary\nremove = Remove\nremoveType = Remove {type}\nremoveMessage = Remove Element\nrequired = Required\nreset = Reset\nrichText = Rich Text Editor\nroles = Access\nrow = Row\nrow.makeInputGroup = Make this row an input group.\nrow.makeInputGroupDesc = Input Groups enable users to add sets of inputs at a time.\nrow.settings.fieldsetWrap = Wrap row in a &lt;fieldset&gt; tag\nrow.settings.fieldsetWrap.aria = Wrap Row in Fieldset\ncannotClearFields = There are no fields to clear\nsave = Save\nsecondary = Secondary\nselect = Select\nselectColor = Select Color\nselectionsMessage = Allow Multiple Selections\nselectOptions = Options\nseparator = Separator\nsettings = Settings\nsize = Size\nsizes = Sizes\nsizes.lg = Large\nsizes.m = Default\nsizes.sm = Small\nsizes.xs = Extra Small\nstyle = Style\nstyles = Styles\nstyles.btn = Button Style\nstyles.btn.danger = Danger\nstyles.btn.default = Default\nstyles.btn.info = Info\nstyles.btn.primary = Primary\nstyles.btn.success = Success\nstyles.btn.warning = Warning\nsubtype = Type\nsuccess = Success\ntext = Text Field\nthen = Then\ntoggle = Toggle\nungrouped = Un-Grouped\nwarning = Warning\nyes = Yes\nand = and\nor = or\nfield.property.value = value\nfield.property.label = label\nfield.property.valid = valid\nfield.property.invalid = not valid\nfield.property.isVisible = is visible\nfield.property.isNotVisible = is not visible\nnewOptionLabel = New {type}\noperator.visible = visible\noperator.notVisible = not visible\noperator.equals = equals\noperator.notEquals = not equal\noperator.contains = contains\noperator.notContains = not contains\ncondition.target.placeholder = target\nif.condition.target.placeholder = target / value\nif.condition.source.placeholder = source\nthen.condition.target.placeholder = target\ncondition.value.placeholder = value\nattributeNotPermitted = Attribute \"{attribute}\" is not permitted, please choose another.\n");
var defaults = {
  get editor() {
    return {
      stickyControls: false,
      allowEdit: true,
      dataType: 'json',
      debug: false,
      sessionStorage: false,
      editorContainer: null,
      external: {},
      svgSprite: null,
      iconFont: null,
      config: {},
      events: {},
      actions: {},
      controls: {},
      polyfills: Object(helpers["g" /* isIE */])(),
      i18n: {
        location: 'https://draggable.github.io/formeo/assets/lang/'
      }
    };
  }

};
// CONCATENATED MODULE: ../src/demo/assets/img/formeo-sprite.svg
/* harmony default export */ var formeo_sprite = ("<?xml version=\"1.0\" encoding=\"utf-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><symbol viewBox=\"0 0 16 16\" id=\"f-i-autocomplete\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6 5h1v1H6V5zM4 4H3v1h1V4zm2 0H5v1h1V4zM2 5v1h1V5H2zm1 2h1V6H3v1zm2 0h1V6H5v1zM4 5v1h1V5H4zm-2 9h1v-1H2v1zm2 0h1v-1H4v1zm2 0h1v-1H6v1zm3-1H8v1h1v-1zm7-9.5v4c0 .8-.7 1.5-1.5 1.5H14v6c0 .6-.4 1-1 1H1c-.6 0-1-.4-1-1V3.5C0 2.7.7 2 1.5 2H8V1H6V0h5v1H9v1h5.5c.8 0 1.5.7 1.5 1.5zM13 12H1v3h12v-3zM3 11v-1H2v1h1zm2 0v-1H4v1h1zm10-7.5c0-.3-.2-.5-.5-.5H9v5H8V7H7V6h1V5H7V4h1V3H1.5c-.3 0-.5.2-.5.5v4c0 .3.2.5.5.5H8v1H6v1h5V9H9V8h5.5c.3 0 .5-.2.5-.5v-4z\"/></symbol><symbol viewBox=\"0 0 32 32\" id=\"f-i-bin\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 10v20c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V10H4zm6 18H8V14h2v14zm4 0h-2V14h2v14zm4 0h-2V14h2v14zm4 0h-2V14h2v14zM26.5 4H20V1.5c0-.825-.675-1.5-1.5-1.5h-7c-.825 0-1.5.675-1.5 1.5V4H3.5C2.675 4 2 4.675 2 5.5V8h26V5.5c0-.825-.675-1.5-1.5-1.5zM18 4h-6V2.025h6V4z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-button\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M.477 4A.477.477 0 000 4.477v7.046A.477.477 0 00.477 12h15.046a.477.477 0 00.477-.477V4.477A.477.477 0 0015.523 4H.477zm.476.953h14.094v6.094H.953V4.953z\" color=\"#000\" font-weight=\"400\" font-family=\"sans-serif\" overflow=\"visible\"/><g font-weight=\"400\" font-size=\"5\" font-family=\"Sans\" letter-spacing=\"0\" word-spacing=\"0\"><path d=\"M6.17 6.51q-.537 0-.854.4Q5 7.31 5 8q0 .689.315 1.09.317.4.854.4.537 0 .85-.4.315-.401.315-1.09 0-.69-.315-1.091-.313-.4-.85-.4zm0-.4q.767 0 1.226.514.459.513.459 1.377 0 .862-.46 1.377-.458.513-1.225.513-.769 0-1.23-.513-.46-.513-.46-1.377t.46-1.377Q5.4 6.11 6.17 6.11zM8.626 6.175h.493v1.54l1.636-1.54h.635l-1.81 1.7 1.94 1.945h-.65L9.12 8.065V9.82h-.494V6.175z\"/></g></symbol><symbol viewBox=\"0 0 32 32\" id=\"f-i-calendar\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.048 16.961c-.178.257-.395.901-.652 1.059a2.57 2.57 0 01-.869.328 4.594 4.594 0 01-1.002.079v1.527h2.467V26h1.991v-9.996h-1.584c-.056.381-.173.7-.351.957zM23 8h2a1 1 0 001-1V1a1 1 0 00-1-1h-2a1 1 0 00-1 1v6a1 1 0 001 1zM7 8h2a1 1 0 001-1V1a1 1 0 00-1-1H7a1 1 0 00-1 1v6a1 1 0 001 1zm23-4h-2v5a1 1 0 01-1 1h-6a1 1 0 01-1-1V4h-8v5a1 1 0 01-1 1H5a1 1 0 01-1-1V4H2a2 2 0 00-2 2v24a2 2 0 002 2h28a2 2 0 002-2V6a2 2 0 00-2-2zm0 25a1 1 0 01-1 1H3a1 1 0 01-1-1V13a1 1 0 011-1h26a1 1 0 011 1v16zM15.985 17.982h4.968c-.936 1.152-1.689 2.325-2.265 3.705-.575 1.381-.638 2.818-.749 4.312h2.131c.009-.666-.195-1.385-.051-2.156.146-.771.352-1.532.617-2.285.267-.752.598-1.461.996-2.127a7.049 7.049 0 011.367-1.686v-1.742h-7.015v1.979z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-checkbox\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.5 5v8c0 .8-.7 1.5-1.5 1.5H3c-.8 0-1.5-.7-1.5-1.5V4c0-.8.7-1.5 1.5-1.5h9c.7 0 1.3.5 1.5 1.2l2.4-1.4L13.5 5zm-1 1.2L7.7 12 2.8 5.5l4.9 1.6 4.8-2.9V4c0-.3-.2-.5-.5-.5H3c-.3 0-.5.2-.5.5v9c0 .3.2.5.5.5h9c.3 0 .5-.2.5-.5V6.2z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-checkbox-group\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 1h16V0H0v1zm0 2h16V2H0v1zm6 2v1h9V5H6zm9 9v-1H6v1h9zm-9-4h9V9H6v1zm-2 2l-2.5 1.5L0 13l1.5 2L4 12zm0-4L1.5 9.5 0 9l1.5 2L4 8zm0-4L1.5 5.5 0 5l1.5 2L4 4z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-columns\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16 .5a.5.5 0 00-.5-.5H.5a.5.5 0 00-.5.5v15a.5.5 0 00.5.5h15a.5.5 0 00.5-.5V.5zM15 1v14h-4V1h4zm-5 0v14H6V1h4zM5 1v14H1V1h4z\" color=\"#000\" font-weight=\"400\" font-family=\"sans-serif\" overflow=\"visible\"/></symbol><symbol viewBox=\"0 0 32 32\" id=\"f-i-copy\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M20 8V0H6L0 6v18h12v8h20V8H20zM6 2.828V6H2.828L6 2.828zM2 22V8h6V2h10v6l-6 6v8H2zm16-11.172V14h-3.172L18 10.828zM30 30H14V16h6v-6h10v20z\"/></symbol><symbol viewBox=\"0 0 15 15\" id=\"f-i-divider\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 7h15v1H0z\"/></symbol><symbol viewBox=\"0 0 28 32\" id=\"f-i-edit\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M22 2l-4 4 6 6 4-4-6-6zM0 24l.021 6.018L6 30l16-16-6-6L0 24zm6 4H2v-4h2v2h2v2z\"/></symbol><symbol viewBox=\"0 0 32 32\" id=\"f-i-floppy-disk\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 0H0v32h32V4l-4-4zM16 4h4v8h-4V4zm12 24H4V4h2v10h18V4h2.343L28 5.657V28z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-handle\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 5h2v2H2zM7 5h2v2H7zM12 5h2v2h-2z\"/><g><path d=\"M2 9h2v2H2zM7 9h2v2H7zM12 9h2v2h-2z\"/></g></symbol><symbol viewBox=\"0 0 448 512\" id=\"f-i-hash\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M448 192v-64h-80.064l16-128h-64l-16 128H175.968l16-128h-64l-16 128H0v64h103.968L88 320H0v64h80L64 512h64l16-128h127.968l-16 128H320l16-128h112v-64H344l15.936-128H448zM279.968 320H152l15.968-128h127.968l-15.968 128z\"/></symbol><symbol viewBox=\"0 0 28 28\" id=\"f-i-header\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M26.281 26q-.688 0-2.07-.055t-2.086-.055q-.688 0-2.063.055T17.999 26q-.375 0-.578-.32t-.203-.711q0-.484.266-.719t.609-.266.797-.109.703-.234q.516-.328.516-2.188l-.016-6.109q0-.328-.016-.484-.203-.063-.781-.063H8.749q-.594 0-.797.063-.016.156-.016.484l-.016 5.797q0 2.219.578 2.562.25.156.75.203t.891.055.703.234.313.711q0 .406-.195.75t-.57.344q-.734 0-2.18-.055t-2.164-.055q-.672 0-2 .055T2.062 26q-.359 0-.555-.328t-.195-.703q0-.469.242-.703t.562-.273.742-.117.656-.234q.516-.359.516-2.234l-.016-.891V7.814l.008-.406q.008-.359 0-.57t-.023-.602-.055-.656-.102-.57-.172-.492-.25-.281q-.234-.156-.703-.187t-.828-.031-.641-.219-.281-.703q0-.406.187-.75t.562-.344q.719 0 2.164.055t2.164.055q.656 0 1.977-.055t1.977-.055q.391 0 .586.344t.195.75q0 .469-.266.68t-.602.227-.773.063-.672.203q-.547.328-.547 2.5l.016 5q0 .328.016.5.203.047.609.047h10.922q.391 0 .594-.047.016-.172.016-.5l.016-5q0-2.172-.547-2.5-.281-.172-.914-.195t-1.031-.203-.398-.773q0-.406.195-.75t.586-.344q.688 0 2.063.055t2.063.055q.672 0 2.016-.055t2.016-.055q.391 0 .586.344t.195.75q0 .469-.273.688t-.625.227-.805.047-.688.195Q24 4.615 24 6.772l.016 14.734q0 1.859.531 2.188.25.156.719.211t.836.07.648.242.281.695q0 .406-.187.75t-.562.344z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-hidden\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1 5h1V4H1zM3 5h1V4H3zM5 5h1V4H5zM7 5h1V4H7zM9 5h1V4H9zM11 5h1V4h-1zM13 5h1V4h-1zM0 6h1V5H0zM15 7h1V6h-1zM0 8h1V7H0zM15 9h1V8h-1zM0 10h1V9H0zM15 11h1v-1h-1zM2 12h1v-1H2zM4 12h1v-1H4zM6 12h1v-1H6zM8 12h1v-1H8zM10 12h1v-1h-1zM12 12h1v-1h-1zM14 12h1v-1h-1zM15 5h1V4h-1zM0 12h1v-1H0z\" color=\"#000\" font-weight=\"400\" font-family=\"sans-serif\" overflow=\"visible\"/></symbol><symbol viewBox=\"0 0 384 512\" id=\"f-i-menu\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 96v64h384V96H0zm0 192h384v-64H0v64zm0 128h384v-64H0v64z\"/></symbol><symbol viewBox=\"0 0 16 32\" id=\"f-i-minus\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 14v4h16v-4H0z\"/></symbol><symbol viewBox=\"0 0 512 512\" id=\"f-i-move\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M287.744 94.736v129.008h128v-64L512 256l-96.256 96.24v-65.488h-128V415.76h64.496L256 512l-96.256-96.24h64V286.752h-128v64.992L0 256l95.744-95.744v63.488h128V94.736h-62.496L256 0l94.752 94.736h-63.008z\"/></symbol><symbol viewBox=\"0 0 512 512\" id=\"f-i-move-vertical\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M287.744 94.736V415.76h64.496L256 512l-96.256-96.24h64V94.736h-62.496L256 0l94.752 94.736z\"/></symbol><symbol viewBox=\"0 0 20 28\" id=\"f-i-paragraph\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.969 2.953v1.141q0 .453-.289.953t-.664.5q-.781 0-.844.016-.406.094-.5.484-.047.172-.047 1v18q0 .391-.281.672t-.672.281h-1.687q-.391 0-.672-.281t-.281-.672V6.016h-2.234v19.031q0 .391-.273.672t-.68.281H9.158q-.406 0-.68-.281t-.273-.672v-7.75q-2.297-.187-3.828-.922-1.969-.906-3-2.797-1-1.828-1-4.047 0-2.594 1.375-4.469 1.375-1.844 3.266-2.484Q6.752 2 11.534 2h7.484q.391 0 .672.281t.281.672z\"/></symbol><symbol viewBox=\"0 0 578.106 578.106\" id=\"f-i-phone-receiver\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M577.83 456.128c1.225 9.385-1.635 17.545-8.568 24.48l-81.396 80.781c-3.672 4.08-8.465 7.551-14.381 10.404-5.916 2.857-11.729 4.693-17.439 5.508-.408 0-1.635.105-3.676.309-2.037.203-4.689.307-7.953.307-7.754 0-20.301-1.326-37.641-3.979s-38.555-9.182-63.645-19.584c-25.096-10.404-53.553-26.012-85.376-46.818-31.823-20.805-65.688-49.367-101.592-85.68-28.56-28.152-52.224-55.08-70.992-80.783-18.768-25.705-33.864-49.471-45.288-71.299-11.425-21.828-19.993-41.616-25.705-59.364S4.59 177.362 2.55 164.51-.306 141.56.102 134.216c.408-7.344.612-11.424.612-12.24.816-5.712 2.652-11.526 5.508-17.442s6.324-10.71 10.404-14.382L98.022 8.756c5.712-5.712 12.24-8.568 19.584-8.568 5.304 0 9.996 1.53 14.076 4.59s7.548 6.834 10.404 11.322l65.484 124.236c3.672 6.528 4.692 13.668 3.06 21.42-1.632 7.752-5.1 14.28-10.404 19.584l-29.988 29.988c-.816.816-1.53 2.142-2.142 3.978s-.918 3.366-.918 4.59c1.632 8.568 5.304 18.36 11.016 29.376 4.896 9.792 12.444 21.726 22.644 35.802s24.684 30.293 43.452 48.653c18.36 18.77 34.68 33.354 48.96 43.76 14.277 10.4 26.215 18.053 35.803 22.949 9.588 4.896 16.932 7.854 22.031 8.871l7.648 1.531c.816 0 2.145-.307 3.979-.918 1.836-.613 3.162-1.326 3.979-2.143l34.883-35.496c7.348-6.527 15.912-9.791 25.705-9.791 6.938 0 12.443 1.223 16.523 3.672h.611l118.115 69.768c8.571 5.308 13.67 12.038 15.303 20.198z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-radio-group\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 1h16V0H0v1zm0 2h16V2H0v1zm5 3h10V5H5v1zm10 3H5v1h10V9zm0 5v-1H5v1h10zM1.5 7C.7 7 0 6.3 0 5.5S.7 4 1.5 4 3 4.7 3 5.5 2.3 7 1.5 7zm0-2c-.3 0-.5.2-.5.5s.2.5.5.5.5-.2.5-.5-.2-.5-.5-.5zm0 6.1c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5S3 8.7 3 9.6s-.7 1.5-1.5 1.5zm0-2c-.3 0-.5.2-.5.5s.2.5.5.5.5-.3.5-.5-.2-.5-.5-.5zm0 5.9C.7 15 0 14.3 0 13.5S.7 12 1.5 12s1.5.7 1.5 1.5S2.3 15 1.5 15zm0-2c-.3 0-.5.2-.5.5s.2.5.5.5.5-.2.5-.5-.2-.5-.5-.5z\"/></symbol><symbol viewBox=\"0 0 512 512\" id=\"f-i-remove\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M44.491 106.237l61.746-61.746L467.51 405.763l-61.746 61.746z\"/><path d=\"M405.763 44.491l61.746 61.746L106.237 467.51l-61.746-61.746z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-rich-text\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15 1H1c-.6 0-1 .4-1 1v12c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V2c0-.6-.4-1-1-1zM1 3.1h.8v.3H1v-.3zm0 .5h.8v.3H1v-.3zM15 14H1V5.1h14V14zm0-9.1H1v-.3h14v.3zm0-.5H1v-.3h.8v.2h1.5v-.2h1.3v.2H6v-.2h1.3v.2h1.5v-.2H10v.2h1.5v-.2h1.3v.2h1.5v-.2h.7v.3zM4.5 3.6v.3H3.3v-.3h1.2zm-1.2-.2v-.3h1.3v.3H3.3zm4 .2v.3H6v-.3h1.3zM6 3.4v-.3h1.3v.3H6zm4 .2v.3H8.8v-.3H10zm-1.2-.2v-.3H10v.3H8.8zm4 .2v.3h-1.3v-.3h1.3zm-1.3-.2v-.3h1.3v.3h-1.3zm3.5.5h-.8v-.3h.8v.3zm0-.5h-.8v-.3h.8v.3zm0-.5h-.8v-.1h-1.5V3h-1.3v-.2H10V3H8.8v-.2H7.3V3H6v-.2H4.5V3H3.3v-.2H1.8V3H1v-.4h14v.3zm0-.5H1v-.3h14v.3zM3 12v-1h10v1H3zm10-2H3V9h10v1zm-2-2H3V7h8v1z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-rows\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.5 16a.5.5 0 00.5-.5V.5a.5.5 0 00-.5-.5H.5a.5.5 0 00-.5.5v4.964A.5.5 0 000 5.5v4.965a.5.5 0 000 .035v5a.5.5 0 00.5.5h15zm-.5-1H1v-4h14v4zm0-5H1V6h14v4zm0-5H1V1h14v4z\" color=\"#000\" font-weight=\"400\" font-family=\"sans-serif\" overflow=\"visible\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-select\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 0v14c0 .6.4 1 1 1h10c.6 0 1-.4 1-1V5h4V0H0zm1 1h10v3H1V1zm0 6h10v3H1V7zm0 7v-3h10v3H1zM15 4h-3V1h3v3zM2 2h1v1H2V2zm0 10h1v1H2v-1zm2 0h1v1H4v-1zm2 0h1v1H6v-1zm3 0v1H8v-1h1zM2 8h1v1H2V8zm2 0h1v1H4V8zm2 0h1v1H6V8zm7.5-4.9l-1-1.1h1.9l-.9 1.1zM2 6V5h1v1H2zm2 0V5h1v1H4z\"/></symbol><symbol viewBox=\"0 0 448 512\" id=\"f-i-settings\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M223.969 175C179.266 175 143 211.266 143 256c0 44.688 36.266 81.031 80.969 81.031 44.719 0 80.719-36.344 80.719-81.031 0-44.734-36-81-80.719-81zm162.344 127.531l-14.594 35.156 29.469 57.875-36.094 36.094-59.218-27.969-35.156 14.438-17.844 54.625-2.281 7.25h-51.016l-22.078-61.656-35.156-14.5-57.952 29.344-36.078-36.063 27.938-59.25-14.484-35.125L.002 282.594V231.61l61.703-22.109 14.485-35.094-25.953-51.234-3.422-6.719 36.031-36.031 59.297 27.922 35.109-14.516 17.828-54.594 2.297-7.234h51l22.094 61.734 35.063 14.516 58.031-29.406 36.063 36.031-27.938 59.203 14.438 35.172 61.875 20.125v50.969l-61.688 22.187z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-text-input\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15 4H4.5V3H6V2H2v1h1.5v1H1c-.6 0-1 .5-1 1v6c0 .6.4 1 1 1h2.5v1H2v1h4v-1H4.5v-1H15c.6 0 1-.4 1-1V5c0-.5-.4-1-1-1zM1 11V5h2.5v6H1zm14 0H4.5V5H15v6z\"/></symbol><symbol viewBox=\"0 0 16 16\" id=\"f-i-textarea\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 11v-1h8v1H3zm0-4h10V6H3v1zm0 1v1h10V8H3zm10-4H3v1h10V4zm3 10V2c0-.6-.4-1-1-1H1c-.6 0-1 .4-1 1v12c0 .6.4 1 1 1h14c.6 0 1-.4 1-1zM15 2v12H1V2h14z\"/></symbol><symbol viewBox=\"0 0 24 32\" id=\"f-i-triangle-down\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 12l11.992 11.992L23.984 12H0z\"/></symbol><symbol viewBox=\"0 0 12 32\" id=\"f-i-triangle-left\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 15.996l11.992 11.992V4.004L0 15.996z\"/></symbol><symbol viewBox=\"0 0 12 32\" id=\"f-i-triangle-right\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M.002 4.008L11.994 16 .002 27.992V4.008z\"/></symbol><symbol viewBox=\"0 0 24 32\" id=\"f-i-triangle-up\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.992 8L0 19.992h23.984L11.992 8z\"/></symbol><symbol viewBox=\"0 0 512 512\" id=\"f-i-upload\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M240 352H0v128h480V352H240zm208 64h-64v-32h64v32zM112 160L240 32l128 128h-80v160h-96V160z\"/></symbol></svg>");
// CONCATENATED MODULE: ../src/js/editor.js
/* unused harmony export FormeoEditor */


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }













var editor_FormeoEditor = function () {
  function FormeoEditor(_ref, userFormData) {
    var formData = _ref.formData,
        options = _objectWithoutPropertiesLoose(_ref, ["formData"]);

    var _this = this;

    var mergedOptions = Object(utils["h" /* merge */])(defaults.editor, options);

    var actions = mergedOptions.actions,
        events = mergedOptions.events,
        debug = mergedOptions.debug,
        config = mergedOptions.config,
        editorContainer = mergedOptions.editorContainer,
        opts = _objectWithoutPropertiesLoose(mergedOptions, ["actions", "events", "debug", "config", "editorContainer"]);

    if (editorContainer) {
      this.editorContainer = typeof editorContainer === 'string' ? document.querySelector(editorContainer) : editorContainer;
    }

    this.opts = opts;
    dom["a" /* default */].setOptions = opts;
    components["e" /* default */].config = config;
    this.userFormData = userFormData || formData;
    this.Components = components["e" /* default */];
    common_events["a" /* default */].init(_objectSpread({
      debug: debug
    }, events));
    common_actions["a" /* default */].init(_objectSpread({
      debug: debug,
      sessionStorage: opts.sessionStorage
    }, actions));

    _this.loadResources().then(function () {
      if (opts.allowEdit) {
        _this.edit = _this.init.bind(_this);

        _this.init();
      }
    });
  }

  var _proto = FormeoEditor.prototype;

  _proto.loadResources = function loadResources() {
    var promises = [];

    if (this.opts.polyfills) {
      Object(loaders["e" /* loadPolyfills */])(this.opts.polyfills);
    }

    if (this.opts.style) {
      promises.push(Object(loaders["d" /* insertStyle */])(this.opts.style));
    }

    if (this.opts.svgSprite) {
      promises.push(Object(loaders["a" /* ajax */])(this.opts.svgSprite, loaders["b" /* insertIcons */], function () {
        return Object(loaders["a" /* ajax */])(constants["y" /* FALLBACK_SVG_SPRITE */], loaders["b" /* insertIcons */]);
      }));
    } else {
      promises.push(Object(loaders["b" /* insertIcons */])(formeo_sprite));
    }

    promises.push(mi18n_min_default.a.init(Object.assign({}, this.opts.i18n, {
      locale: utils["l" /* sessionStorage */].get(constants["G" /* SESSION_LOCALE_KEY */])
    })));
    return Promise.all(promises);
  };

  _proto.init = function init() {
    var _this2 = this;

    var _this = this;

    this.load(this.userFormData, _this.opts);
    this.controls = controls["a" /* default */].init(_this.opts.controls, _this.opts.stickyControls);
    _this.formId = components["e" /* default */].get('id');
    this.i18n = {
      setLang: function setLang(formeoLocale) {
        utils["l" /* sessionStorage */].set(constants["G" /* SESSION_LOCALE_KEY */], formeoLocale);
        var loadLang = mi18n_min_default.a.setCurrent(formeoLocale);
        loadLang.then(function () {
          _this2.controls = controls["a" /* default */].init(_this.opts.controls);

          _this.render();
        }, console.error);
      }
    };

    _this.render();
  };

  _proto.load = function load(formData, opts) {
    if (formData === void 0) {
      formData = this.userFormData;
    }

    if (opts === void 0) {
      opts = this.opts;
    }

    return this.Components.load(formData, opts);
  };

  _proto.render = function render() {
    this.stages = Object.values(components["e" /* default */].get('stages'));
    var elemConfig = {
      attrs: {
        className: 'formeo formeo-editor',
        id: this.formId
      },
      content: [this.stages.map(function (_ref2) {
        var dom = _ref2.dom;
        return dom;
      })]
    };

    if (mi18n_min_default.a.current.dir) {
      elemConfig.attrs.dir = mi18n_min_default.a.current.dir;
      dom["a" /* default */].dir = mi18n_min_default.a.current.dir;
    }

    this.editor = dom["a" /* default */].create(elemConfig);
    var controlsContainer = this.controls.container || this.editor;
    controlsContainer.appendChild(this.controls.dom);

    if (this.editorContainer) {
      dom["a" /* default */].empty(this.editorContainer);
      this.editorContainer.appendChild(this.editor);
    }

    common_events["a" /* default */].formeoLoaded = new window.CustomEvent('formeoLoaded', {
      detail: {
        formeo: this
      }
    });
    document.dispatchEvent(common_events["a" /* default */].formeoLoaded);
  };

  _createClass(FormeoEditor, [{
    key: "formData",
    get: function get() {
      return this.Components.formData;
    },
    set: function set(data) {
      if (data === void 0) {
        data = {};
      }

      return this.load(_objectSpread({}, this.userFormData, {}, data), this.opts);
    }
  }, {
    key: "json",
    get: function get() {
      return this.Components.json;
    }
  }]);

  return FormeoEditor;
}();
/* harmony default export */ var editor = __webpack_exports__["a"] = (editor_FormeoEditor);

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(106)))

/***/ }),
/* 63 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(45),
    eq = __webpack_require__(22);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(10);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(46)(module)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(47);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 69 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(127),
    getPrototype = __webpack_require__(48),
    isPrototype = __webpack_require__(49);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(128),
    isObjectLike = __webpack_require__(16);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 73 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(134),
    isArguments = __webpack_require__(72),
    isArray = __webpack_require__(17),
    isBuffer = __webpack_require__(34),
    isIndex = __webpack_require__(54),
    isTypedArray = __webpack_require__(50);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(17),
    isKey = __webpack_require__(147),
    stringToPath = __webpack_require__(148),
    toString = __webpack_require__(25);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(36);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var createCaseFirst = __webpack_require__(155);

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;


/***/ }),
/* 79 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(174),
    arraySome = __webpack_require__(177),
    cacheHas = __webpack_require__(178);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(82),
    getSymbols = __webpack_require__(56),
    keys = __webpack_require__(57);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(83),
    isArray = __webpack_require__(17);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(83),
    getPrototype = __webpack_require__(48),
    getSymbols = __webpack_require__(56),
    stubArray = __webpack_require__(84);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(94),
    createAssigner = __webpack_require__(137);

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

module.exports = mergeWith;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var baseSet = __webpack_require__(146);

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(153);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var capitalize = __webpack_require__(154),
    createCompounder = __webpack_require__(55);

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 92 */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),
/* 93 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(41),
    assignMergeValue = __webpack_require__(64),
    baseFor = __webpack_require__(124),
    baseMergeDeep = __webpack_require__(126),
    isObject = __webpack_require__(9),
    keysIn = __webpack_require__(35),
    safeGet = __webpack_require__(74);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 95 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(30);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(29);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(29),
    Map = __webpack_require__(42),
    MapCache = __webpack_require__(44);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(43),
    isMasked = __webpack_require__(109),
    isObject = __webpack_require__(9),
    toSource = __webpack_require__(63);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(23);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(110);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(113),
    ListCache = __webpack_require__(29),
    Map = __webpack_require__(42);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(114),
    hashDelete = __webpack_require__(115),
    hashGet = __webpack_require__(116),
    hashHas = __webpack_require__(117),
    hashSet = __webpack_require__(118);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(31);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 115 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(31);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(31);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(31);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(32);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 120 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(32);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(32);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(32);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(125);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(64),
    cloneBuffer = __webpack_require__(66),
    cloneTypedArray = __webpack_require__(67),
    copyArray = __webpack_require__(69),
    initCloneObject = __webpack_require__(70),
    isArguments = __webpack_require__(72),
    isArray = __webpack_require__(17),
    isArrayLikeObject = __webpack_require__(129),
    isBuffer = __webpack_require__(34),
    isFunction = __webpack_require__(43),
    isObject = __webpack_require__(9),
    isPlainObject = __webpack_require__(131),
    isTypedArray = __webpack_require__(50),
    safeGet = __webpack_require__(74),
    toPlainObject = __webpack_require__(133);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(20),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(33),
    isObjectLike = __webpack_require__(16);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 130 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(20),
    getPrototype = __webpack_require__(48),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(20),
    isLength = __webpack_require__(73),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(24),
    keysIn = __webpack_require__(35);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9),
    isPrototype = __webpack_require__(49),
    nativeKeysIn = __webpack_require__(136);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(138),
    isIterateeCall = __webpack_require__(145);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(13),
    overRest = __webpack_require__(139),
    setToString = __webpack_require__(141);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(140);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 140 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(142),
    shortOut = __webpack_require__(144);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(143),
    defineProperty = __webpack_require__(65),
    identity = __webpack_require__(13);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 143 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 144 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(22),
    isArrayLike = __webpack_require__(33),
    isIndex = __webpack_require__(54),
    isObject = __webpack_require__(9);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(53),
    castPath = __webpack_require__(76),
    isIndex = __webpack_require__(54),
    isObject = __webpack_require__(9),
    toKey = __webpack_require__(77);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(17),
    isSymbol = __webpack_require__(36);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(149);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(150);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(44);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(23),
    arrayMap = __webpack_require__(152),
    isArray = __webpack_require__(17),
    isSymbol = __webpack_require__(36);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(76),
    toKey = __webpack_require__(77);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(25),
    upperFirst = __webpack_require__(78);

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var castSlice = __webpack_require__(156),
    hasUnicode = __webpack_require__(79),
    stringToArray = __webpack_require__(158),
    toString = __webpack_require__(25);

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var baseSlice = __webpack_require__(157);

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var asciiToArray = __webpack_require__(159),
    hasUnicode = __webpack_require__(79),
    unicodeToArray = __webpack_require__(160);

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;


/***/ }),
/* 159 */
/***/ (function(module, exports) {

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;


/***/ }),
/* 161 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var deburrLetter = __webpack_require__(163),
    toString = __webpack_require__(25);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var basePropertyOf = __webpack_require__(164);

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var asciiWords = __webpack_require__(166),
    hasUnicodeWord = __webpack_require__(167),
    toString = __webpack_require__(25),
    unicodeWords = __webpack_require__(168);

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;


/***/ }),
/* 168 */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9),
    now = __webpack_require__(170),
    toNumber = __webpack_require__(171);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(10);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9),
    isSymbol = __webpack_require__(36);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(173),
    isObjectLike = __webpack_require__(16);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(41),
    equalArrays = __webpack_require__(80),
    equalByTag = __webpack_require__(179),
    equalObjects = __webpack_require__(182),
    getTag = __webpack_require__(37),
    isArray = __webpack_require__(17),
    isBuffer = __webpack_require__(34),
    isTypedArray = __webpack_require__(50);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(44),
    setCacheAdd = __webpack_require__(175),
    setCacheHas = __webpack_require__(176);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),
/* 175 */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),
/* 176 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),
/* 177 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(23),
    Uint8Array = __webpack_require__(68),
    eq = __webpack_require__(22),
    equalArrays = __webpack_require__(80),
    mapToArray = __webpack_require__(180),
    setToArray = __webpack_require__(181);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),
/* 180 */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),
/* 181 */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(81);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),
/* 183 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(49),
    nativeKeys = __webpack_require__(185);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(71);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(18),
    root = __webpack_require__(10);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(41),
    arrayEach = __webpack_require__(191),
    assignValue = __webpack_require__(53),
    baseAssign = __webpack_require__(192),
    baseAssignIn = __webpack_require__(193),
    cloneBuffer = __webpack_require__(66),
    copyArray = __webpack_require__(69),
    copySymbols = __webpack_require__(194),
    copySymbolsIn = __webpack_require__(195),
    getAllKeys = __webpack_require__(81),
    getAllKeysIn = __webpack_require__(196),
    getTag = __webpack_require__(37),
    initCloneArray = __webpack_require__(197),
    initCloneByTag = __webpack_require__(198),
    initCloneObject = __webpack_require__(70),
    isArray = __webpack_require__(17),
    isBuffer = __webpack_require__(34),
    isMap = __webpack_require__(202),
    isObject = __webpack_require__(9),
    isSet = __webpack_require__(204),
    keys = __webpack_require__(57);

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),
/* 191 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(24),
    keys = __webpack_require__(57);

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(24),
    keysIn = __webpack_require__(35);

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(24),
    getSymbols = __webpack_require__(56);

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(24),
    getSymbolsIn = __webpack_require__(85);

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(82),
    getSymbolsIn = __webpack_require__(85),
    keysIn = __webpack_require__(35);

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),
/* 197 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(47),
    cloneDataView = __webpack_require__(199),
    cloneRegExp = __webpack_require__(200),
    cloneSymbol = __webpack_require__(201),
    cloneTypedArray = __webpack_require__(67);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(47);

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),
/* 200 */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(23);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(203),
    baseUnary = __webpack_require__(51),
    nodeUtil = __webpack_require__(52);

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(37),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(205),
    baseUnary = __webpack_require__(51),
    nodeUtil = __webpack_require__(52);

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(37),
    isObjectLike = __webpack_require__(16);

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormeoEditor", function() { return FormeoEditor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormeoRenderer", function() { return FormeoRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormeoControls", function() { return FormeoControls; });
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _components_controls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);




if (window !== undefined) {
  window.FormeoEditor = _editor__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"];
  window.FormeoRenderer = _renderer__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];
}

var FormeoEditor = _editor__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"];
var FormeoRenderer = _renderer__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];
var FormeoControls = _components_controls__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"];
/* harmony default export */ __webpack_exports__["default"] = ({
  FormeoEditor: FormeoEditor,
  FormeoRenderer: FormeoRenderer,
  FormeoControls: FormeoControls
});

/***/ })
/******/ ]);
});